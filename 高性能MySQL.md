# 高性能MySQL

## MySQL 基准测试

### sysbench

* Centos 和 Mac OS安装参考：`https://github.com/akopytov/sysbench`
* CPU 基准测试：
  * `sysbench --test=cpu --cpu-max-prime=20000 run`
    * 测试计算素数直到某个最大值所需要的时间

# 服务器性能剖析

## 性能优化简介

* 重要的原则：性能就是响应时间
* 就数据库而言，数据库服务器关注的任务是 SQL 语句执行所消耗的时间，即查询的响应时间
* 优化：可以说是尽可能地降低响应时间
* 资源：性能优化就是降低CPU利用率，以减少资源的使用，是一个误区。资源是用来消耗支撑工作的，故而较多资源投入使用，可以加快查询速度
* 吞吐量优化：提升每秒的查询量
* 找出查询消耗较多时间的原因，然后对症优化
* 合适的测量范围：只测量需要优化的活动
* 不合适的测量：
  * 在错误的时间启动和停止测量
  * 测量的是聚合后的信息，而非目标活动本身：抓住主要矛盾不放手

### 通过性能剖析进行优化

* 测量和分析消耗的时间主要方法
* 测量任务花费的时间、对结果进行统计和排序
* 安装 `https://www.cnblogs.com/zishengY/p/6852280.html`
* 执行时间：查询时间 + 等待时间。需要分别就出来并分别分析

### 理解性能剖析

* 判断哪些是值得优化的查询，没有回报的优化就放弃
* 异常情况：对执行频率较低，但是每次都慢，影响用户体验的要优化
* 未知的未知
  * 丢失的时间：任务执行的时间与测量到的时间之间的差值
  * 测量工具没有测量到某些任务、测量工具经度的问题
* 被掩藏的细节
  * 性能剖析只显示了平均时间的行为，无法显示所有的响应时间的分布
  * 需要额外的诸如：直方图、百分比、标准偏差等信息

## 对应用程序进行性能剖析

* 对任何需要消耗时间的任务都可以进行性能剖析。建议自上而下，追踪用户发起到服务器响应时间的整个流程
* 外部资源( 调用了外部服务 ) -> 应用处理大量数据( 分析超大的XML文件 ) -> 循环中执行昂贵的操作( 使用了正则 ) -> 低效的算法 -> 等等

## 剖析 MYSQL 查询

* 剖析整个数据库服务器
* 剖析具体的单个查询

### 剖析服务器负载

* 剖析并找出代价高的查询：慢查询日志

* 捕获 MYSQL 的查询到日志文件中

  * 慢查询
    * 加强版的慢查询日志：设置 `long_query_time = 0` 来捕获所有的查询
    * 查询的响应时间达到了微妙级别
    * 慢查询日志是开销最低、精度最高的工具
    * 可能会消耗大量的磁盘空间，尽量不要长期开启或者使用日志轮转工具
  * 通用日志
    * 很少用于剖析服务器性能、秒级别、意义不大

* 分析查询日志

  * From now on：**利用慢查询捕获服务器上的所有查询，并进行分析**
  * 工具：`pt_query_digest`。将慢查询日志文件传给 **pt_query_digest** 即可
  * 通过 `yum` 安装 `pt_query_digest`。通过 `show variables like '%slow%';` 查找出慢日志文件位置
  * Mac：/usr/local/mysql/data/ACA80168-slow.log
  * Centos： /var/lib/mysql/hostname-slow.log

  ```bash
  $ pt_query_digest hostname-slow.log
  输出如下：
  # 150ms user time, 10ms system time, 25.75M rss, 220.07M vsz
  # Current date: Sun Nov 11 15:13:36 2018
  # Hostname: iZbp11jt0i73lffge9yew8Z
  # Files: iZbp11jt0i73lffge9yew8Z-slow.log
  # Overall: 1 total, 1 unique, 0 QPS, 0x concurrency ______________________
  # Time range: all events occurred at 2018-11-11T03:33:50
  # Attribute          total     min     max     avg     95%  stddev  median
  # ============     ======= ======= ======= ======= ======= ======= =======
  # Exec time            10s     10s     10s     10s     10s       0     10s
  # Lock time              0       0       0       0       0       0       0
  # Rows sent              1       1       1       1       1       0       1
  # Rows examine           0       0       0       0       0       0       0
  # Query size            29      29      29      29      29       0      29
  
  # Profile
  # Rank Query ID                           Response time  Calls R/Call  V/M
  # ==== ================================== ============== ===== ======= ===
  #    1 0x3E9BCB8A9A63A4079C8EDD53C741D289 10.0003 100.0%     1 10.0003  0.00 SELECT
  
  # Query 1: 0 QPS, 0x concurrency, ID 0x3E9BCB8A9A63A4079C8EDD53C741D289 at byte 0
  # This item is included in the report because it matches --limit.
  # Scores: V/M = 0.00
  # Time range: all events occurred at 2018-11-11T03:33:50
  # Attribute    pct   total     min     max     avg     95%  stddev  median
  # ============ === ======= ======= ======= ======= ======= ======= =======
  # Count        100       1
  # Exec time    100     10s     10s     10s     10s     10s       0     10s
  # Lock time      0       0       0       0       0       0       0       0
  # Rows sent    100       1       1       1       1       1       0       1
  # Rows examine   0       0       0       0       0       0       0       0
  # Query size   100      29      29      29      29      29       0      29
  # String:
  # Hosts        localhost
  # Users        root
  # Query_time distribution
  #   1us
  #  10us
  # 100us
  #   1ms
  #  10ms
  # 100ms
  #    1s
  #  10s+  ################################################################
  # EXPLAIN /*!50100 PARTITIONS*/
  select sleep(10) as a, 1 as b\G
  ```

* 其余略之

# schema 和数据类型优化

* 反范式的设计可以加快某些类型的查询，但是也会使得另一些查询变慢

## 选择优化的数据类型

* 更小的通常更好：选择可以正确存储数据的最小数据类型。通常更快：占用更少的磁盘、内存、CPU缓存
* 简单就好：简单的通常需要更少的CPU周期。整型比字符串的代价地：字符集和校对规则使字符比整型更复杂
* 避免使用 NULL：通常情况尽量指定为 not null
  * NULL 列使得 MYSQL 的优化更难，NULL 列使得索引、索引统计和值比较都更复杂
  * NULL 列会使用更多空间，mysql 也需要额外处理
  * NULL 列被索引时，每个索引记录需要一个额外的字节
  * 将 NULL 列改为 NOT NULL 列带来的性能提升比较小，但仍然需要避免使用
* 为列选择合适的数据类型
  * 数字、字符、时间
  * 如：DATETIME、TIMESTAMP 都可以存储时间和日期，精确到秒
    * TIMESTAMP 只使用 DATTIME 一半的存储空间
    * TIMESTAMP 会根据时区变化，具有自动更新能力
    * TIMESTAMP 允许的时间范围较小，有时候会成为障碍

### 整数类型

* 两种类型的数字：整数和实数
* 整数
  * TINYINT、SMALLINT、MIDIUMINT、INT、BIGINT，分别使用 8、16、24、32、64 位存储空间
  * 整型选择 UNSIGNED 表示不允许负值，可以正数的上限提高一倍。但是性能相同

### 实数类型

* 带有小数部分的数字。可以使用 DECIMAL 存储比 BIGINT 还大的整数
* DECIMAL：存储精确的小数。MySQL 5.0和更高版本将数字打包保存到一个二进制字符串中，每4字节存储9个数字
  * DECIMAL(18,9)：小数点两边将各存储9个数字，各需要4个字节，小数点本身占用一个字节，共需9字节
  * DECIMAL 是一种存储形式，在计算中会转换为 DOUBLE 类型（代码中为 double）
* 浮点类型 FLOAT 和 DOUBLE。比 DECIMAL 占用更少的空间
  * FLOAT 占用4字节
  * DOUBLE 占用8字节，比 FLOAT 有更高的精度和范围
* 只在有小数时才使用DECIMAL，因为DECIMAL需要额外的空间

### 字符串类型

* VARCHAR

  * 存储可变长字符串，常用于存储字符串。比定长类型更省空间。需要额外1~2个字节记录字符串长度
  * update 时可能需要做额外的工作，因为涉及到更新的数据变化导致其存储可能发生变化，页分裂等

* CHAR

  * 定长存储。适合存储较短的字符串，或者存储的数据都接近一个长度，适合存储密码的 MD5 值
  * 也适合于经常变更的数据，不容易产生碎片
  * 不需要字符长度的额外记录所需要的一字节空间
  * 只分配真正需要的空间

* BLOB 和 TEXT 先略过

* ENUM 代替字符串

  * 存储时比较紧凑。会根据列表的值的数量将其压缩到一或者两个字节中，mysql 内部会将每个值在列表中的位置保存为整数，并在表的.frm 文件中保存数字和字符串的映射关系
  * 且其内部是按照映射中的数字排序的，而非字符串顺序

  ```mysql
  mysql> create table enum_test (
  	-> e ENUM('fish', 'apple', 'dog') not null   
  	-> );
  mysql> insert into enum_test (e) values ('fish'), ('dog'),('apple');
  mysql> select e + 0 from enum_test;
  +-------+
  | e + 0 |
  +-------+
  |	  1 |
  |	  3 |
  |	  2 |
  +-------+
  ```

  * 由上可见，避免在 enum 中存储数字

### 日期和时间类型

* DATETIME
  * 保存较大的范围，从1001 年到 9999 年，精度为秒
  * 8字节存储空间
  * UNIX_TIMESTAMP( ) 函数将日期转换为 Unix 时间戳
* TIMESTAMP
  * 保存了自 1970年1月1日午夜以来的秒数，和 Unix 时间戳相同
  * 从 1970 年到 2038 年
  * 4字节存储空间
  * FROM_UNIXTIME( ) 函数将 Unix 时间戳转换为日期
* 尽量使用 TIMESTAMP，比DATETIME空间效率更高
* 不推荐整数保存时间戳，处理不方便且没有任何收益

### 位数据类型

* BIT，尽量避免使用之
* 其余目前忽略

### 选择标识符

* 整数类型，是标识列最好的选择，很快且可以使用自增
* ENUM 和 SET：尽量避免使用
* 字符串：消耗较大的空间，且比数字类型慢。也尽量避免
* 注意：一些随机产生的数据，如 MD5、SHA1、UUID 等函数产生的数据通常会分布在很大的空间内
  * 导致 INSERT 变慢：随机值会随机到索引不同的位置，分不到随机的页中或者页分裂
  * 导致 SELECT 变慢：导致逻辑上相邻的行会分布到磁盘或者内存的不同地方

## Schema 设计中的陷阱

* 太多的列：数千个字段
* 太多的关联：每个关联操作只能有61个表，最好在12个以内
* 全能的枚举：防止过度的枚举，即枚举的字段值分布过多
* 无能为力的时候可以设置 NULL 值

## 范式和反范式

* 范式：表更小，更新操作较快，数据冗余较少；关联操作可能过多，可能导致索引失效
* 反范式：避免了过多的关联，更有效地使用索引
* 混合使用

## 缓存表和汇总表

* 满足检索的需求时，可以创建完全独立的表
* 物化视图和计数器表

# 创建高性能索引

## 索引基础

* 索引可以包含多个列，列的顺序也很重要，最左前缀列可以被高效利用

### 索引类型

* 索引是在存储引擎层而不是服务器层实现的，不同存储引擎的工作方式不一样

* B-Tree 索引
  * 使用 B-Tree 数据结构存储数据。二叉查找树（binary tree），`O(log2n)`。顺序查找：`O(n)`
  * InnoDB 使用的是 B+Tree
  * InnoDB 使用原数据格式存储，而非压缩技术
  * 所有的值都是按顺序存储的，且每一个叶子页到到根的距离相同
  * 加快数据的访问：不需要进行全表扫描；从索引的根节点开始检索，根节点的槽中存放了指向子节点的指针。存储引擎根据这些指针向下层查找，通过比较节点页的值和要查找的值，可以找到合适的指针进入下层子节点
  * ![image](https://github.com/rayest/Document/raw/master/images/二叉树存储.png)
  * 上图：左边是数据表、右边是数据记录的物理地址`(逻辑上相邻的记录在磁盘中并非物理相邻)`。为了加快Col2 的查找，可以维护一个最右边的二叉查找树。每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针
  * B-Tree
    * 每个节点都是一个二元数组：[key, data]，所有节点都可以存储数据
    * ![image](https://github.com/rayest/Document/raw/master/images/B-Tree.png)
    * 插入时可能会破坏已经存在的结构，产生树的分裂、合并、转移等操作以继续维持B-Tree性质，IO频繁
  * B+Tree
    * B-Tree 的变种。非叶子节点不存储 data，只存储索引 Key，只有叶子节点才存储 data
    * ![image](https://github.com/rayest/Document/raw/master/images/B+Tree.png)
  * MySQL 中的 B+Tree
    * 在上述的B+Tree 上进行了优化，增加了顺序访问指针。在每个叶子节点增加了一个指向相邻叶子节点的指针
    * 即为带有顺序访问指针的B+Tree，提高了区间访问性能：如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率(**无需返回上层父节点重复遍历查找减少IO操作**)
    * ![image](https://github.com/rayest/Document/raw/master/images/MySQL中B+Tree.png)
    * 比较适合范围数据的查找

* 哈希索引

  * 基于哈希表实现，只有精确匹配索引所有列的查询才有效

  * 对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码

  * 哈希码是一个较小的值，且不同键值的行计算出的哈希码也不一样

  * 哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针

  * ```javascript
    +———————-——————-+
    | fname | lname	|
    +-------+-------+
    |	A   |   AA  |
    |   B   |   BB  |
    |   C   |   CC  |
    |   D   |   DD  |
    +-------+-------+
    
    有表且其中数据如上，假设使用的哈希函数是 f(), 返回值值如下
    f('A') = 2323
    f('B') = 7437
    f('C') = 8784
    f('D') = 2548
    
    则哈希索引的数据结构如下：
    
    槽(slot)			值(value)
    2323			指向第1行的指针
    2458			指向第4行的指针
    7437			指向第2行的指针
    8784			指向第3行的指针
    
    注意：每个槽的编号是顺序的，但是数据行不是。
    执行 select lname from table where fname = 'C' 时：mysql 先计算 'C' 的哈希值8747，并使用该值寻找对应的记录指针：指向第3行，最后比较第三行的值是否为 'C'
    ```

  * 问题

    * 哈希索引只包含哈希值和行指针，并不存储字段值
    * 哈希索引的数据并不是按照索引值顺序存储的
    * 不支持部分索引列匹配查找，如有两个索引时，但只使用其中之一，则无法使用该索引
    * 只支持等值比较查询，也不支持范围查找
    * 哈希冲突时，索引的维护代价较高

  * InnoDB 有一个特殊的功能，叫做自适应哈希索引，在适时的情况下，让B-Tree索引也具有哈希索引的一些优点。完全自动、内部的行为，用户无法配置和操作，可以关闭

* 全文索引

  * 查找的是文本中的关键词，而非直接比较索引中的值

## 索引优点

* 最常见的B-Tree索引，因为其按照顺序存储数据，所以MySQL可以实现 order by 和 group by 操作
* 索引中存储了实际的值，故而某些查询只使用索引就能够完成全部查询
* 减少服务器需要扫描的数据量
* 避免排序和临时表
* 可以将随机IO变为顺序IO

## 高性能的索引策略

### 独立的列

* 独立的列是指索引列不能是表达式的一部分，也不能是函数的一部分，如果是的话，索引就会失效

```mysql
select actor_id from t_table where actor_id + 1 = 5  # 表达式的一部分，actor_id 索引失效
应该尽量将索引单独放在比较符号的一侧
```

### 前缀索引和索引选择性

* 若索引列较长会使得索引变大且慢，可以考虑索引`开始的部分字符`，以减少空间提高效率
* 降低了索引的选择性：不重复的索引值与数据表的记录总数，高则查询效率高，能过滤掉越多的行
* 唯一索引的选择性是1，最好的索引选择性，即只有一条该记录
* 保证足够长的前缀以保持较高的选择性，接近于完整列的基数，但又不能太长
* 无法 order by 和 group by

### 多列索引

```mysql
CREATE TABLE t(
	c1 INT,
    c2 INT,
    c3 INT,
    KEY(c1),
    KEY(c2),
    KEY(c3)
)
```

* 以上为每个列创建了独立索引，而非多列索引
* 大部分情况下，在多个列上建立独立的单列索引并不能提高 MYSQL 的查询性能

```mysql
SELECT a, b from t where a = 1 OR b =1; # mysql 会优化类似的复杂查询
```

* 有多个索引做相交操作时`(通常有多个AND)`，需要建立一个包含所有相关列的多列索引，而非建立独立的单列索引
* 当多个索引做联合操作时`(通常有多个OR)`，需要建立多列索引。因为需要消耗大量的CPU和内存资源

### 选择合适的索引列顺序

* 在多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列
* 经验法则：将选择性高的列放到索引最前列

```mysql
SELECT a, b from t where a = 1 AND b =1;  # 应该建一个(a,b)索引，如果a的选择性较高的话

ALTER TABLE t ADD KEY(a, b);  # 根据选择性创建多列索引
```

### 聚簇索引

* 不是一种类似于B-Tree索引的单独的索引类型，只是一种数据存储方式
* InnoDB的聚簇索引，实际上在同一个结构中保存了B-Tree索引和数据行
* 一个表只能有一个聚簇索引，因为无法把数据行拆开放到不同的地方
* 所以，插入新行时，可能导致页分裂；插入速度依赖于插入顺序
* 避免使用随机的不连续的且值分布很大的作为聚簇索引，特别是IO密集型的应用，如UUID作为聚簇索引很糟糕

### 覆盖索引

* 一个索引包含所有需要查询的字段的值
* 可以使用索引直接获取列的数据，而不需要再读取行数据。叶子节点中已经包含了要查询的数据
* 只有B-Tree索引可以作为覆盖索引，因为覆盖索引需要存储索引列的值
* MySQL 不能在索引中执行 LIKE 操作

### 使用索引扫描来做排序

* 两种用于生成有序的结果：排序操作和按索引顺序扫描
* explain 出来的 type 列为 index，则为索引扫描来做排序

### 冗余和重复索引

* 在相同的列上按照相同的顺序创建相同类型的索引，需要避免之

```mysql
CREATE TABLE test(
	ID INT NOT NULL PRIMARY KEY,
    A INT NOT NULL,
    B INT NOT NULL,
    UNIQUE(ID),
    INDEX(ID)
) ENGINE=InnoDB;
```

* 以上，即创建了重复索引。创建了三个重复索引
* 冗余索引：如果存在`索引(A,B)`，在创建单独的A索引都属于冗余索引，因为他们都是(A,B)索引的前缀索引
* 而索引 B 和 (B,A) 则不是冗余索引，因为不是其**最左前缀列**
* 尽量扩展已有的索引，而不是新增新索引，以避免冗余索引

### 未使用的索引

* 删除之。查询索引的使用频率

### 索引和锁

* 索引使得查询可以锁定更少的行，减少了锁的竞争与开销
* InnoDB 只有在**访问行**的时候才会对其**加锁**
* InnoDB 可以在过滤掉行后就释放锁

### 案例

* 要点
  * 翻页：前几页较快，越到后面越慢。因为需要大量时间扫描需要丢弃的数据。可以限制用户的翻页数量
  * 避免多个范围条件，尽量转为等值条件

## 维护索引和表

### 找到并修复损坏的表

* 可能是系统崩溃或者是硬件问题
* 导致查询的结果错误或者主键冲突
* 通过适当的命令检查表是否被损坏了：check table；repair table 以修复表；或者 alter table 重建表
* 数据导出，再重建表导入。备份

### 维护正确的索引统计信息

* 先略

### 减少碎片

* 先略

# 查询性能优化

## 慢查询基础

* 最基本的原因是访问的数据太多
* 注意：确认是否在检索大量的数据，访问太多的行
* 注意：确认程序是否在分析大量的数据行

### 是否请求了不需要的行

* 查询了不需要的数据行：然后只需要其中一小部分，大部分数据行被丢弃。增加网络开销、CPU、内存资源
* 如，分页时查询了所有的行，显示时只有小部分
* 查询了全部的列：如 `select *`
*  重复查询相同的数据：相同的查询可以将查询结果缓存起来

### 是否在扫描额外的记录

* 衡量查询开销的指标：响应时间、扫描的行数、返回的行数
* 响应时间
  * 服务时间 + 排队时间（锁等）
* 扫描的行数和返回的行数
  * 关联操作，往往需要扫描多个行以生成结果集的一行
* 扫描的行数和访问类型
  * MySQL 有很多种方式返回一行结果，有些需要扫描很多行，有些可能无需扫描即可返回结果
  * `EXPLAIN` 语句中返回的 type 类型显示了访问的类型
  * 有：全表扫描( type=all )、范围扫描、唯一索引查询、常数引用等，扫描的行数从小到大

## 重构查询的方式

* 使用多个小查询代替复杂的大查询，有时需要衡量
* 如分解关联查询有很多优点
  * 让缓存效率更高，程序可以简单地缓存单条查询结果
  * 执行单个查询可以减少锁的竞争
  * 在应用层做关联，可以更容易对数据库进行拆分，更容易扩展
  * 查询本身的性能会提升
  * 减少冗余数据的查询：关联查询可能会重复访问部分数据
  * 总之，将关联放到程序中会使得更加高效

## 查询执行的基础

* MySQL 执行过程
  * 客户端发送一条查询给服务器
  * 服务器先查询缓存，如命中则直接返回
  * 否则，服务器进行SQL解析、预处理，再由优化器生成对应的**执行计划**
  * 根据执行计划，调用存储引擎的API执行查询
  * 返回结果给客户端

### 客户端和服务端通信协议

* 半双工：任一时刻，客户端和服务端只有一个方向进行数据传送
* 查询状态：通过执行 `SHOW FULL PROCESSLIST` 可以查看命令的执行状态

### 查询缓存

* 若开启了缓存，会优先检查是否命中了缓存中的数据
* 若未命中，则进行查询优化处理阶段

### 查询优化处理

* 将 SQL 转换成一个执行计划，MySQL 再依照这个执行计划和存储引擎进行交互
* 包括：解析 SQL、预处理、优化 SQL 执行计划
* 语法解析器和预处理
  * 通过关键字将 SQL 进行解析。解析器通过 MySQL 语法规则验证和解析查询，检查 SQL 语句的关键字及关键字使用顺序是否正确等
* 查询优化器
  * 通过优化器可以将SQL语法转换成执行计划，一条查询可以有很多执行方式，都返回同样的结果。优化器的作用就是从中找出最好的执行计划
  * 重新定义关联表的顺序
  * 将外连接转换成内连接
  * 使用等价变换规则：简化并规范表达式，合并和减少一些比较，移出一些恒等式和恒不成立的判断
  * 优化 `COUNT()、MIN()、MAX()`
  * 预估并转换为常数表达式
  * 子查询优化：将其转换为效率更高的形式，从而减少多个查询多次对数据库的访问
  * 提前终止查询：当查询结果满足需求的时候，就会立刻停止继续查询
  * 等等......
* 数据和索引的统计信息
  * 查询优化器在生成执行计划的时候，需要向存储引擎获取响应的统计信息
  * 包括：每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行、索引长度等
* 如何执行关联查询
  * 广泛而言，任何一条查询都是一次关联，不仅仅是多表关联
  * 如 UNION 查询：MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表中的数据进行 UNION 操作
  * 略先
* 执行计划
  * MySQL 生成查询的一棵指令树，再通过存储引擎执行完成该指令树并返回结果
  * 最终的执行计划包括了重构查询的全部信息
* 关联查询优化器
  * 关联查询优化。决定了多个表关联时的顺序
* 排序优化
  * 排序的成本很高，尽量避免排序或者尽可能避免对大量数据进行排序

### 查询执行引擎

* 查询执行引擎根据执行计划完成查询

### 返回结果给客户端

* 将查询结果返回给客户端

## 优化特定类型的查询

### 优化 `COUNT()` 查询

* 两个作用
  * 统计某个列的数量
  * 统计行数
* 简单的优化

```mysql
SELECT COUNT(*) FROM t WHERE id > 5;  # 优化前可能扫描很多行

SELECT (SELECT COUNT(*) 
        FROM t) - COUNT(*) 
FROM t WHERE id <= 5;  # 优化后仅会扫描5行以内
```

* 但是一般 COUNT 都需要扫描很多行，难以优化，可以增加**汇总表**

### 优化关联查询

* 确保 ON 或者 USING 子句的列上有索引
* 确保任何的 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列

### 优化 LIMIT 分页

```mysql
SELECT id, coupon_id, user_id FROM t_mysql ORDER BY user_id LIMIT 50, 5;  # 优化前。可能会扫描很多行，选取其中5行数据

SELECT id, coupon_id, user_id
FROM t_mysql
  INNER JOIN (
    SELECT id FROM t_mysql ORDER BY user_id LIMIT 50, 5
) AS lim USING (id);   # 优化后。延迟关联，大大提升查询效率。先获取需要返回的记录后再回表关联需要的列。
```



* 暂略

# 高级特性

## 分区表

* 是一个独立的逻辑表，底层由多个物理表组成
* 在创建表时，使用 PARTITION BY 定义每个分区存放的数据。执行查询时，查询可以只扫描分区表
* 以较粗粒度的方式将数据存储在不同的表中，将相关的数据存放在一起
* 一个表最多1024个分区，分区表无法使用外键约束

```mysql
CREATE TABLE sales (
	order_date DATETIME NOT NULL,
    ......
)ENGINE=InnoDB PARTITION BY RANGE (YEAR(order_date))(
    PARTITION p_2010 VALUES LESS THAN (2010),
    PARTITION p_2010 VALUES LESS THAN (2011),
    PARTITION p_2010 VALUES LESS THAN (2012),
    PARTITION p_catchall VALUES LESS THAN MAXVALUE
);
```

* 分区有很多类型，请参考 **《InnoDB 存储引擎》**篇

## 视图

* 虚拟表，由其他表生成

```mysql
CREATE VIEW Oceania AS SELECT * FROM country WHERE continent = 'Oceania' WITH CHECK OPTION;
SELECT code, name FROM Oceania WHERE name = 'Australia';
```

## 外键约束

* 确保两个表的数据一致
* 使用外键会有额外的开销，额外的锁等待、死锁等问题
* 通常在程序中确保数据约束的一致性，避免外键带来不可控的一系列问题

# 略之

