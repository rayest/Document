## 简单动态字符串

> simple dynamic string ：SDS。Redis 默认的字符串表示。
>
> 保存数据库中的字符串值、作为缓冲区(AOF 缓冲)、客户端状态的输入缓冲区

### 定义

* 示例

  ```c
  struct sdshdr {
      int len;
      int free;
      char buf[]
  }
  ```

* SDS 以空字符结尾‘\0’，但是不计入 SDS 的 len 属性中，分配额外的 1 字节空间

### SDS 与 C 字符串的区别

* 获取字符串长度
> SDS 可以通过 len 属性直接获取，O(1)

* 杜绝缓冲区溢出
* SDS 的空间分配策略杜绝了发生缓冲区溢出的问题

* 当 SDS API 对 SDS 进行修改时，API 先检查 SDS 空间是否满足修改所需的要求。如果不满足，则自动将 SDS 的空间扩展至所需要的大小，再执行修改操作

  > 如：当执行字符串拼接操作时，SDS API 会检查 SDS 空间是否满足拼接后字符串所需要的空间，如果不满足，则 SDS 会扩充空间至所需要的值，再执行拼接操作

* 减少字符串修改带来的内存重分配次数

  > SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关系。即：buf 数组长度未必等于字符串长度再加 1，数组中可以包含未使用的字节。通过 free 属性记录这些未使用的字节数量 

  > 2 种优化策略：空间预分配、惰性空间释放

  * 空间预分配

    * 当 SDS 空间需要扩展时，程序不仅会为其分配所必要大小的空间，还会为其分配额外的未使用的空间
    * 减少了连续执行字符串增长操作所需要的内存分配次数

  * 惰性空间释放

    * 当字符串执行缩短操作时，程序并不立即释放未使用的空间，而是通过 free 属性记录未使用的空间，并等将来使用
    * 在真正需要的时候，通过 SDS API 释放这些未使用的空间

## 链表

### 链表和链表节点的实现

  ```c 
typedef struct listNode {
  	struct listNode *prev;
  	struct listNode *next;
  	void *value;
  }
  ```
```c
typedef struct list{
	listNode *head;
	listNode *tail;
	unsigned long len;
}
```
* 多个 listNode 通过 prev 和 Next 指针实现双端链表
* listNode 中 value 属性记录了节点的值
* 链表由 list 结构和 listNode 结构组成
* list 结构的 head 指针指向由 listNode 组成的双端链表的首个 listNode
* list 结构的 tail 指针指向由 listNode 组成的双端链表的最后一个 listNode 
* list 结构的 len 属性记录了链表的长度，listNode 的数量
* 链表的头结点 prev 指针和尾节点 Next 指针都指向 null，表示访问终点

## 字典

### 实现

* 哈希表

```c
typedef struct dictht {
    dictEntry **table;
	unsigned long size;
	unsigned long sizemask;
	unsigned long used;`
}
```

* 每一个哈希表中可以有多个哈希表节点，每一个哈希表节点保存了字典中的一个键值对
* table 属性是一个数组，数组中的每个元素都是 dictEntry 结构的指针
* 每个 dictEntry 结构都保存了一个键值对
* size 值记录了哈希表的大小（table 数组的大小）
* used 记录了哈希表目前已有的哈希节点数量
* sizemask 值总是 size - 1，用于计算索引值，即决定一个键应该被放到table数组的哪一个索引位置

### 哈希表节点

````c
typedef struct dictEntry{
    void *key;
  	union {值} value;
	struct dictEntry *next;
}
````

* key 是键
* value 是值
* Next 指针指向下一个哈希表节点。该指针可以将多个哈希值相同的键值对连接在一起，以解决哈希冲突

### 字典

* 一个普通的字典结构由2个哈希表组成，ht[0] 用于实际存储键值对数据，ht[1] 用于rehash备用

## 哈希算法

> 当一个新的键值对需要添加到字典中时，需要先根据键计算出哈希值和索引值，根据索引值，将该新的键值对所在的节点放到哈希表数组指定的索引位置

## 解决键冲突

> 当两个或者两个以上的键在经过哈希算法计算后，被分配到哈希数组的同一个索引上时，即发生了键冲突

### 链地址法

> 解决键冲突

* 当出现键冲突时，具有相同索引的节点之间通过 Next 指针连接形成单向链表
* dictEntry 节点组成的链表没有指向链尾的指针，为考虑速度性能，新增的节点插入到链表的表头位置

## Rehash

* 当对字典的插入或者删除操作很多时，哈希表保存的键值对会逐渐地增加或者减少，为使哈希表的负载因子依然合理，当哈希表中键值对数量过多或者过少时，需要对哈希表的大小进行扩展或者收缩
* 为字典的 ht[1] 表分配空间，该空间大小取决于要执行的操作以及 ht[0] 包含的键值对数量
* 负载因子：ht[0].used / ht[0].size
* 当负载因子小于 0.1，自动收缩
* 当服务器目前没有执行 BGSAVE 或者 BGWRITEAOF 命令时，负载因子大于等于 1 时，自动扩展
* 当服务器目前正在执行 BGSAVE 或者 BGWRITEAOF 命令时，负载因子大于等于 5 时，自动扩展

# 跳跃表

* 有序的数据结构
* 每个节点可以指向多个其他节点，实现快速访问

### 实现

* 跳跃表：zskiplist + zskiplistNode
* zskiplist 记录了跳跃表的相关信息：节点数量、指向表头节点的指针、指向表尾节点的指针、最大层数 level ( 表头节点不算 )
* zskiplistNode
  * level：层，各个节点的层数，每个层带有前进指针 ( 指向表尾方向的其他节点 ) 和跨度 ( 前进指针两端节点之间的距离 )，节点层数越多，访问其他节点速度越快
  * 前进指针：程序从表头向表尾遍历时使用
  * backward：后退指针，指向当前节点的前一个节点。从表尾向表尾遍历时使用
  * 分值：跳跃表的排列顺序按照分值从小到大顺序排列
  * 成员对象：各个节点还保存了成员对象

# 整数集合

> 当集合中仅包含整数，且集合元素不是很多时

## 实现

* encoding、length、contents[ ]
* 集合中的每个元素都是 contents 中的一个数组项 item，且从小到大有序排列，没有重复项
* length 记录了集合的大小，亦即 contents 数组的大小

## 升级

* 当新添加元素的类型比集合中其他元素的类型长时，需要对集合进行升级，再讲新数添加到集合中
* 3 步
  * 根据新元素的类型，扩展集合底层数组的空间大小，并为新元素分配空间
  * 将其余元素转换成与新元素相同的类型，并将新元素放到正确的位上
  * 将新元素放到数组中
* 提升了集合灵活性：不会因为某一种固定的整数类型而被匡住而出现类型错误，可以自由地升级
* 节约内存：使得集合可以同时保存不同类型的值，在有需要的时候才进行升级。因材施教、牛刀宰牛、鸡刀杀鸡
* 已经升级，状态一直保存。不存在降级

# 压缩列表

> Ziplist 

* 当列表键中只包含少量的列表项，且每个列表项或为小整数，或为短字符创，即会采用压缩列表作为列表键的实现
* 如 1 2 3 4 1000 “Hello”，“Name” 这样的简单整数和字符
* 哈希键亦如是：哈希键只包含少量的键值对或者键和值都比较小或者短
* 节约内存

# 对象

* Redis 数据结构：简单动态字符串、双端链表、字典、压缩列表、整数集合
* 或曰：Redis 5 种数据结构，字符串、字典、列表、集合、有序集合
* Redis 并未直接使用以上所说的数据结构以实现键值对数据库，而是为其构建了对应的对象系统

## 对象类型与编码

* 类型：字符串对象 string、哈希对象 hash、列表对象 list、集合对象 set、有序集合对象 zset
* 每种对象可以设置不同的编码，而非每种对象固定为一种特定的编码，使得对象可以根据使用场景动态地按需设置自己的编码格式，灵活且高效
* 编码即 encoding，是具体的数据结构。以上介绍的几种数据结构

## 对象介绍

* 包括各对象的编码格式、编码转换：略

## 类型检查与命令多态

* Redis 有两种用于操作键的命令，一种是通用型的可用于对任何类型的键，一种是只能用于指定类型键
* 因此在执行命令时，需要对命令及其将要作用的对象进行检查，以确定二者是否匹配

### 类型检查的实现

* 在执行特定类型的命令前，服务器先检查输入的数据库键的值是否是需要的类型
* 如果是，则服务器就执行该条命令
* 如果不是，服务器拒绝执行该条命令，并且向客户端返回类型错误

### 多态命令的实现

> Redis 除了会根据数据值对象的类型来判断键是否能够执行指定命令外，还会根据数据值对象的编码方式，选择正确的命令来执行代码，这种方式即为多态

## 内存回收

> Redis 通过自己内建的引用计数（refCount）方式实现了内存回收。程序可以跟踪对象的引用计数信息，在适当的时候自动释放对象并回收内存

* 对象创建时，引用计数的值会被初始化为1

* 对象被新程序使用时，其值加1

* 对象不再被一个程序使用时，其值减1

* 当对象的引用计数值为0时，对象所占用的内存被释放

  > 对象的整个生命周期：创建对象、操作对象、释放对象

## 对象共享

* 对象的引用计数除了用于实现内存回收机制外，还可以实现对象共享
* 当两个键需要指向两个同样的值对象时，可以只创建一个值对象，两个键只需要都指向该值对象就可以了
* 节约内存，当数据库中保存的相同值对象越多时，共享机制节约的内存越多
* 类似于 Linux 的链接
* 将数据库键的值指针指向一个现有的值对象
* 将被共享的值对象的引用计数加1

## 对象的空转时长

> 属性：lru。记录对象最后一次被命令访问的时间

* 空转时长（idletime）：当前时间 - lru

# 数据库

* Redis 服务器将所有数据库都保存在服务器状态 redisServer 结构的 db 数组中。db 数组的每一项都是一个 redisDb 结构，每个 redisDb 都代表了一个数据库。redisServer 的 dbnum 属性记录了数据库的数量

## 切换数据库

* Redis 共有16 个数据库可供选择，默认为 0 号数据库
* 服务器内部的客户端状态记录了客户端当前的目标数据库
* Redis 命令 SELECT 可以修改客户端数据库的指针，使其指向不同数据库，实现数据库的切换

## 数据库键空间

* Redis 是键值对数据库服务器。数据库 redisDb 结构中的 dict 保存了所有的键值对，曰为：键空间
* 键空间的键也就是数据库的键，每个键都是字符串对象
* 键空间的值也就是数据库的值，每个值都可以是以上介绍过的5种对象中的一种

### 添加键

* 添加新的键值对到数据库中，就是将该键值对添加到键空间的字典中

### 删除键

* 删除数据库中的键值对，就是将键空间中的键及其值对象删除

### 更新键

* 更新数据库的键，就是对键空间中的相关的键对应的值对象进行更新

### 对键取值

* 对指定数据库的键取值，就是在键空间中找到该键对应的值对象

### 读写键空间时额外的维护操作

* 写操作之前也需要进行读操作
* 读取时，服务器根据该键是否存在，来更新键空间命中次数和不命中次数
* 读键时，服务器会更新键的 LRU 时间，用于计算键的闲置时间
* 读键时，若发现键已过期，服务器先删除该键，再执行下一步操作
* 如果有客户端对某个键使用了 WATCH 命令进行监视，则服务器在对该键进行修改之后，会将该键标记为‘脏’
* 服务器每次修改一个键后，都会对脏键计数器加1，该计数器会触发服务器的持久化及复制操作
* 如果服务器开启了数据库通知功能，则键被修改之后，服务器将按配置发送相应的数据库通知

## 键的生存时间和过期时间

* redisDb 结构的 expires 字典中保存了数据库中所有键的过期时间，该字典称之为过期字典
* 过期字典的键是一个指针，指向键空间中的某个键对象
* 过期字典的值是一个整数，保存了键所指向的数据库键的过期时间
* 检查指定键是否存在于字典中，如果存在，获取该键的过期时间，检查当前时间戳是否大于键的过期时间

## 过期键删除策略

### 定时删除

* 设置键的过期时间的时候，创建一个定时器，在定时器在键的过期时间来临时，立即执行删除键
* 对 CPU 不友好，在过期键比较多时，删除过期键的行为会占用很多 CPU 时间

### 惰性删除

* 不设立定时器，每次从键空间获取键时，检查键是否过期，过期则删除键，未过期则返回该键
* 对内存不友好，过期的键可能未得到及时删除，而驻留在内存中。极端情况下，有些过期键得不到删除，成为永久的垃圾

### 定期删除

* 每隔一段时间，程序对数据库进行一次检查，删除其中的过期键
* 综合了以上两种删除策略的优点，兼顾了 CPU 和内存友好性

## Redis 的过期键删除策略

* Redis 采用了惰性删除和定期删除的两种策略

## AOF、RDB 和复制功能对过期键的处理

### 生成 RDB 文件

* 执行 save 或者 bgsave 命令时，会创建一个新的 RDB 文件，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的 RDB 文件中

### 载入 RDB 文件

> 启动服务器时，如果开启了 RDB 功能，则服务器将会对 RDB 文件进行载入

* 若服务器以主服务器模式运行
  * 则在载入 RDB 文件时，程序对文件中保存的键进行检查，
  * 未过期的键会被载入到主服务器的数据库中，过期的被忽略
* 若服务器以从服务器的模式运行
  * 则在载入 RDB 文件时，文件中保存的所有键，不论是否过期都会载入到从服务器的数据库
  * 在主从服务器进行数据同步的时候，从服务器的数据库会被清空

### AOF 文件写入

* 当服务器以 AOF 持久化模式运行时，若数据库中的某个键已经过期，但是还未被删除， AOF 文件不会因此而有影响
* 当过期键被删除后，程序会向 AOF 文件追加一条 DEL 命令，以显式地记录该键被删除

### AOF 重写

* 类似于生成 RDB 文件，在执行 AOF 重写时，数据库会先检查数据的键，过期的键不会被保存到重写后的 AOF 文件

### 复制

* 当服务器运行在复制模式下时，从服务器的过期键的删除动作由主服务器控制
* 主服务器在删除一个过期键时，会显式地向所有从服务器发送一个 DEL 命令，告知各从服务器删除这个过期键
* 从服务器在执行客户端发送过来的读取命令时，即使碰到过期键也不会将其删除，仍然会返回给客户端
* 从服务器在接收到主服务器发送过来的 DEL 命令后，才会删除该过期键

## 数据库通知

> 使得客户端通过订阅给定的频道或者模式，以获得数据库中键的变化和数据库中命令的执行情况

### 发送通知

* 数据库通知的发送是由内置的函数实现的，实现向客户端发送数据库通知
* 函数根据事件的名称、产生事件的键、产生事件的数据库号码、事件类型、接收通知的频道名

# RDB 持久化

* 数据库状态：服务器中非空数据库及其键值对
* Redis 是内存数据库，数据库状态都存在内存中，为避免服务进程退出导致数据的丢失，Redis 提供了 RDB 持久化功能
* RDB 可以将内存中的数据生成快照持久化到磁盘中，可以手动执行，也可以根据自定义配置定期执行。可以将某个时间点上的数据库状态保存到一个 RDB 文件中
* RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态
* RDB 文件是保存在磁盘中的

## RDB 文件的创建和载入

* 两种创建 RDB 文件的命令，SAVE 和 BGSAVE
* SAVE：会阻塞 Redis 进程，直到 RDB 文件创建完成为止。在此期间，服务器不处理任何请求
* BGSAVE：会派生一个子进程，由子进程负责创建 RDB 文件，服务器进程继续处理其他任务
* RDB 文件的载入是服务器启动时自动执行的，如果存在 RDB 文件，就会自动载入 RDB 文件
* 若服务器开启了 AOF 持久化功能，则服务器会先用 AOF 文件还原数据库状态。因为 AOF 文件的更新频率比较高

## 自动间隔性保存

* 可以设置服务器配置的 save 选项，让服务器每隔一段时间自动执行 BGSAVE 命令
  * save 900 1：服务器在 900 秒内，对数据库进行了至少 1 次修改
  * save 300 10：服务器在 300 秒内，对数据库进行了至少 10 次修改
  * save 60 10000：服务器在 60 秒内，对数据库进行了至少 10000 次修改
  * 当数据库状态满足以上任意一个条件时，BGSAVE 命令就会自动执行
* 服务器状态还维持着 dirty 计数器和 lastleave 属性
  * dirty：在上一次SAVE 或者 BGSAVE 之后，服务器对数据库的修改次数
  * lastleave：时间戳，上一次 SAVE 或者 BGSAVE 的时间
* Redis 服务器周期性操作函数 serverCron 每隔 100 毫秒就会执行一次，以维护正在运行的服务器。其中一项工作就是检查 save 选项是否满足条件，通过 dirty 和 lastleave 计算判断

# AOF 持久化

* RDB 通过保存数据库的键值对来记录数据库状态的（Redis Database）
* AOF 通过保存服务器执行的写命令来记录数据库状态的（Append only file）

## 实现

* 命令追加、文件写入、文件同步三步走

### 命令追加

* 当启用 AOF 持久化功能时，在服务器执行完写命令后，会将被执行的命令追加到服务器状态的 aof_buf 缓冲区中

### 文件写入和同步

* Redis 服务器的进程就是一个事件循环，其中的文件事件负责接收客户端的命令请求和回复，其中的时间事件负责执行一些定时函数
* 服务器在每次结束一个事件循环之前，调用相关函数，判断是否需要将缓冲区中的数据写入和保存到 AOF 文件中

## AOF 文件载入和数据还原

* AOF 文件中保存了重建数据库状态所需要的所有写命令，故服务器只需要读入并重新执行一遍AOF文件中的写命令即可
* 创建一个不带网络的伪客户端，从 AOF 文件中分析并读取一条写命令，执行读出的命令，直至命令处理完

## AOF 重写

* 当 AOF 文件中保存了过多的命令时，使得文件本身过大，可能对服务器和宿主机造成影响，且数据库状态还原时间也会变长。为此，需要 AOF 重写机制解决上述问题
* 使用新的 AOF 文件代替旧的 AOF 文件。新文件不会有冗余的命令，体积小。如：集合操作可以使用一条命令代替多条命令，因为同样功能的命令格式一样，只是值不同

### 实现

* 不需要分析和读取现有的 AOF 文件实现，而是通过读取服务器当前的数据库状态实现
* 先从数据库中读取键现在的值，然后使用一条命令记录该键值对，代替之前的多条命令

### AOF 后台重写

* AOF 重写可能花费较长的时间，致使服务器无法处理其他的客户端请求，因此需要后台重写
* 将 AOF 重写交给子进程。服务器进程继续处理其他请求。

# 事件

## 文件事件

* Redis 服务器通过套接字与客户端连接，而文件事件就是服务器对套接字的抽象
* 服务器和客户端的通信会产生文件事件
* 服务器通过监听并处理这些文件事件以完成网络通信操作

### 文件事件处理器

* 使用IO多路复用程序同时监听多个套接字，并为其关联不同的时间处理器
* 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，相关的文件事件就会产生
* 此时，文件处理器就会调用之前关联好的文件处理器进行事件处理
* 单线程使用多路复用实现高性能网络通信模型
* 4 个组成部分：套接字、IO多路复用程序、文件事件分派器、事件处理器。有点类似 spring 处理请求的方式

## 时间事件

* 服务器的一些操作是需要在给定时间点执行，即为时间事件
* 分为定时事件和周期性事件
* 所有的时间事件都被放在一个无序链表中，当时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件，调用相应的事件处理器进行处理
* 无序是指事件的排序不是按照时间进行排序的，在时间上是无序的

# 补充

* redis 是单线程的

## 6种数据淘汰策略

* **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近**最少使用**的数据淘汰
* **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选**将要过期**的数据淘汰
* **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中**随机选择**数据淘汰
* **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
* **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
* **no-enviction**（驱逐）：禁止驱逐数据

## 分布式锁
* 如何在高并发中使用 redis
```java
@Service
public class Main {

    @Resource
    private StringRedisTemplate redisTemplate;

    private void test() {
        String clientId = UUID.randomUUID().toString(); // 为每个客户端请求生成一个唯一标识
        try {
            redisTemplate.opsForValue().setIfAbsent("key", "value" + clientId); // 调用底层 setNx 方法，加锁
            redisTemplate.expire("key", 10, TimeUnit.SECONDS); // 锁有效期时间，过期自动释放
            Thread.sleep(5); // 模拟业务处理
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 判断如果客户端的锁是自己的，就在业务处理完之后释放锁
            if (("value" + clientId).equals(redisTemplate.opsForValue().get("key"))) {
                redisTemplate.delete("key");
            }
        }
    }
}
```

* 或者使用 redission API
> 1. reddsion 在加锁后，会开启一个线程，每隔一定时间判断锁是否被释放，如果没有的话，就延长加锁时间为刚才设置的值，从而确保业务有足够时间执行完。
> 2. 
```java
Rlock lock = redission.getLock();
lock.lock(10, time);
```

> 3. 但是在主从架构中，redis 的 slave 副本是需要复制 master 主节点数据的。当 master 获取到应用线程A的锁且还未来得及被 slave 同步数据时，突然宕机。此时的 slave 有机会升为 master 节点，但是却并未及时同步到之前的锁，应用线程B会停止阻塞状态以获取锁，就会破坏分布式锁的实现，导致不一致
> 4. 因此可使用 redLock 或者 更建议使用 zookeeper 实现分布式锁

## 主从复制

> 1. Master 和 slave：主节点负责写和从节点负责读，从节点需要向主节点复制数据，保持同步
> 2. 主从之间的通信，可以通过客户端命令实现。如 slaveof ip port ；ping

## setinel 哨兵

> 1. 哨兵：是一个分布式系统也是redis服务器，通常设为单数台。主要的作用是监控每台服务器，当发生故障的时候，发起投票选举新的 master，并将其余的 slave 重新连接的该新的 master。
>2. 监控、通知、故障自动转移。
> 3. 一主二从三哨兵：1个master 节点、2个slave 节点、3个哨兵节点

# Redis 单机集群搭建

> 1. 复制 redis 文件夹到本目录下，以构建一主二从服务集群
> 2. 修改三个文件夹下的 redis.conf 和 sentinel.conf 文件配置
>
> ```bash
> # master redis.conf 配置
> port 6379
> masterauth "redis123"
> requirepass redis123
> # master sentinel.conf 配置
> port 26379
> sentinel monitor mymaster 127.0.0.1 6379 2
> sentinel auth-pass mymaster redis123
> 
> # slave1 redis.conf 配置
> port 6380
> masterauth "redis123"
> requirepass redis123
> 
> # slave1 sentinel.conf 配置
> port 26380
> sentinel monitor mymaster 127.0.0.1 6379 2
> sentinel auth-pass mymaster redis123
> 
> # slave2 redis.conf 配置
> port 6381
> masterauth "redis123"
> requirepass redis123
> # slave2 sentinel.conf 配置
> port 26381
> sentinel monitor mymaster 127.0.0.1 6379 2
> sentinel auth-pass mymaster redis123
> ```
>
> 3. 分别启动 master 和 slave1 、slave2 
>
> ```shell
> $ src/redis-server redis.conf # 在 redis.conf 配置中关闭 后台启动选项，以便观察日志
> ```
>
> 4. 分别启动三个客户端
>
> ```shell
> $ src/redis-cli -p 6379
> $ src/redis-cli -p 6380
> $ src/redis-cli -p 6381
> ```
>
> 5. 测试 master 和 slave 的读写权限
>
> ```shell
> # master 读写请求
> 127.0.0.1:6381> get name
> "le"
> 127.0.0.1:6381> set name leee
> OK
> 127.0.0.1:6381> get name
> "leee"
> 
> # slave1 读写请求
> 127.0.0.1:6380> get name
> "leee"
> 127.0.0.1:6380> set name le
> (error) READONLY You can't write against a read only slave.
> 
> # slave2 读写请求
> 127.0.0.1:6381> get name
> "leee"
> 127.0.0.1:6381> set name le
> (error) READONLY You can't write against a read only slave.
> ```
>
> 6. 分别启动 master 的 sentinel 和 slave 的 sentinel
>
> ```shell
> $ src/redis-sentinel sentinel.conf
> 
> # 通过客户端命令在各自的客户端会观察到 master 和 slave 之间的注册信息
> 127.0.0.1:6380> info replication
> # Replication
> role:slave
> master_host:127.0.0.1
> master_port:6381
> master_link_status:up
> master_last_io_seconds_ago:1
> master_sync_in_progress:0
> slave_repl_offset:413713
> slave_priority:100
> slave_read_only:1
> connected_slaves:0
> master_repl_offset:0
> repl_backlog_active:0
> repl_backlog_size:1048576
> repl_backlog_first_byte_offset:0
> repl_backlog_histlen:0
> ```
>
> 7. 主备切换/故障转移
>
> ```shell
> # kill 掉 master 服务器进程。哨兵会在两个 slave 之间自动选举出一个作为新的 master。
> ```
>
> 