# Docker 简介 

* 基于 Linux 内核的 cgroup 、namespace 以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术
* 由于隔离的进程独立于宿主和其他的隔离进程，故而亦称其为容器
* 传统的虚拟化技术：虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需要的应用进程
* Docker 容器：容器内的应用进程直接运行于宿主机的内核，容器没有自己的内核，而且也没有进行硬件虚拟，因此更加轻便
* 更高效的利用系统资源：应用执行速度、内存损耗、文件存储速度都比传统虚拟机更高效。一个相同配置为主机，往往可以运行更多数量的应用
* 更快速的启动时间：由于直接寄宿于宿主内核，无需启动完整的操作系统，启动更加快速
* 一致的运行环境：Docker 镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性
* 持续交付和部署：通过 Dockerfile 进行镜像构建，并结合 CI 系统进行集成测试、自动部署

# 基本概念

* 三个基本概念：镜像、容器、仓库

## Docker 镜像

* 操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间
* Docker 镜像相当于是一个 root 文件系统。是一个特殊的文件系统，除了提供容器运行时所需要的程序、库、资源、配置等文件外，还包含了为运行时准备的一些配置参数，如匿名卷、环境变量、用户等
* 镜像不包含任何动态数据，且其内容在创建后不会改变

### 分层存储

* 镜像包含操作系统完整的 root 文件系统，体积表庞大。Docker 利用 Union FS 技术，将其设计为分层的技术架构。Docker 镜像是由多层文件系统组成
*  镜像构建时，会一层一层构建，前一层是后一层构建的基础。每一层构建成功之后都不会再改变，后一层的任何改变只发生在自己的一层

## Docker 容器

* 镜像和容器的关系就像面向对象中类和实例的关系。镜像是静态的定义，而容器是镜像运行时的实体。容器可以创建、启动、停止、删除和暂停的
* 容器的实质就是进程，但与直接在宿主机执行的进程不同，容器进程是运行于属于自己的独立的命名空间。因此容器拥有自己的 `root` 文件系统、网络配置、进程空间以及自己的用户 ID 空间
* 容器的进程时运行在一个隔离的环境中。使用时，如同在一个独立于宿主机的系统下操作
* 容器和镜像一样，使用分层技术。容器运行时，以镜像为基础层，在其上创建当前容器的存储层，该层为容器运行时读和写而准备
* 容器存储层的生命周期和容器一样，容器消亡时，容器也随之消亡。任何保存于容器存储层中的信息都会随着容器的删除而丢失
* 容器不应该向其存储层写入任何数据，容器存储层要保持无状态化。所有数据的写入要使用数据卷或者绑定宿主目录
* 数据卷的生命周期独立于容器。数据卷不会因为容器的消亡而消亡

## Docker Registry

* 镜像构建成功之后，可以在宿主机上运行。为了使其在其他机器上运行，需要一个集中的存储、分发镜像的服务，称之为  `Docker registry`
* 一个 `Docker registry` 可以包含多个仓库。每个仓库可以包含多个标签 `tag`，每个标签对应一个镜像，标签对应于该软件的各个版本
* 可以通过 `仓库名:标签` 的格式来指定具体版本的镜像。如 `ubuntu:16.04`

# 使用镜像

* 获取镜像：`docker pull` 从指定的镜像仓库获取镜像。下载时按照镜像的层文件逐层下载
* 运行容器：`docker run` 通过下载或者自己创建的镜像，以此为基础启动并运行一个容器
* 列出镜像：`docker image ls` 列出已经下载或者创建的所有镜像。列出的每一个镜像的吸管吸信息中都包含：`仓库名`，`标签`，`镜像ID`，`创建时间`，`所占用的空间`
* 镜像体积：镜像下载之后，其体积为该镜像展开后的各层所占用的空间总和，是未经压缩的大小。列表中所有镜像体积总和并不是所有镜像实际硬盘消耗，因为docker 镜像是分层存储结构，可以继承和复用，不同镜像可以使用相同的基础镜像而拥有共同的层，而相同的层只需要保存一份即可。通过命令 `docker system df` 可以查看镜像、容器和数据卷占用的空间
* 虚悬镜像：镜像列表中一个特殊的镜像，没有仓库名、标签，均为 `<none>`。没有实际意义，通过命令 `docker image prune`删除
* 中间层镜像：用于加速镜像构建、重复利用资源。在使用一段时间后，会出现一些依赖的中间层镜像。默认的 `docker image ls` 只会显示顶层镜像。`docker image ls -a` 可以显示包括中间层镜像在内的所有镜像。这里的=出现的一些无标签的虚悬镜像是其他镜像依赖的中间层镜像，不能删除
* 列出部分镜像：`docker image ls ubuntu` 可以列出指定为 `ubuntu` 的所有镜像 

## 删除本地镜像

* `docker image rm <镜像>` ：可以删除一个或者多个指定的镜像
* 可以通过镜像名、镜像端ID、镜像长ID、镜像摘要删除指定的镜像
* docker 在删除镜像时，即为删除某个标签的镜像。
  * 所以首先需要取消要删除镜像的标签，如果一个镜像有多个标签，当删除其中一个标签对应的镜像时，仅仅将该标签取消 `untagged`，实际上并不真正删除镜像 `deleted`
  * 除此之外，如果镜像的某一层为其他镜像所依赖，则只删除其它层，该依赖层不能删除
  * 删除镜像时，如果有用该镜像启动的容器正在运行，也无法删除。因为容器依赖该镜像，先删除容器再删除镜像

## 利用 commit 理解镜像构成

* `docker run --name webserver -d -p 80:80 nginx`：用 `nginx` 镜像启动容器，名为 `webserver`，并且映射了端口 `80`。启动成功之后，可以通过 IP 和端口访问
* `docker run -it ubuntu bash` 命令也可以进入由 ubuntu 镜像启动的容器 shell。
* 可以通过容器内部的 shell 对容器文件进行修改，修改的任何数据都会记录于容器存储层中。再通过 `docker commit` 将容器的存储层保存下来，形成新的镜像
* docker 修改的数据都是在当前层进行修改，之前层的文件不会改变。通过该种方式会让镜像更加臃肿

## 使用 Dockerfile 定制镜像

* 该文件由一条条指令组成，每一条指令构建一层。每一条指令的内容描述了改层该如何构建
* `from`：指定基础镜像
  * 定制镜像是以一个镜像为基础，在其上进行定制。from 就是指定一个基础镜像，必须为 dockerfile 的第一条指令
  * 特殊的 `from scratch`，以 scratch 为基础镜像意味着不以任何镜像为基础，接下来所写的指令将作为进行第一层而使用
* `run`：指令是用于执行命令行命令的，最为常用
  * shell 格式（如直接在命令行输入一样）
  * exec 格式（像是函数调用中的格式）
  * 每个 run 指令的行为都会新建立一层，并执行这些 run 命令，执行结束后，commit 这一层的修改，构成新镜像
  * 在编写 run 指令时需要考虑是否需要在一层实现，如果仅实现一个目的，可以通过 `&&` 符号将多个 run 命令简化为一个，以使构建层数尽可能的少，减少不必要的臃肿
  * 在对每一层进行构建后，需要清理删除不必要的文件，免得镜像过于臃肿
*  构建镜像：`docker build` 可以指定最终镜像的名称和标签，构建成功之后，可以运行
* 进行构建上下文（context）：`docker build ` 命令最后有一个 `.`，表示当前目录，用于指定上下文路径
  * docker 运行时分为 docker 引擎（服务端守护进程）和客户端工具
  * docker 引擎提供了一系列 REST API，docker 命令这样的客户端工具通过这组 API 与 Docker 引擎交互，完成各种功能。表面上看是在本地执行各种 docker 功能，实际上是通过`远程过程调用` 在服务端完成这些工作的。（类似于 redis 及其客户端）
  * 在进行镜像构建的时候，并非所有的定制都是通过 run 命令实现的，还有其他指令以实现使用本地文件
  * docker build 构建镜像时，并非在本地构建，而是在服务端实现的，即在 docker 引擎中构建。为使服务器获得本地文件，引入了上下文概念
  * 构建时，用户会指定构建镜像的上下文路径。当 docker build 得知该路径后，会将路径下的所有文件打包，然后上传给 docker 引擎。docker 引擎获得该上下文包后，展开就会获得构建镜像所需要的一切文件

## Dockerfile 指令

* `copy`
  * 将构建上下文目录中的文件（源文件）复制到新的一层镜像内（目标路径）
  * 如果目标路径不存在，复制文件前会自动创建
  * 源文件的各种数据都会保留，如执行权限和文件变更时间等
* `add`： 是更高级的复制文件，但是仍更推荐使用 copy 指令
* `cmd`
  * 用于指定默认的容器主进程的启动命令的。推荐使用 exec 格式的命令
  * docker 作为容器即进程，在启动的时候，需要指定运行所需要的参数和程序
  * docker 不是虚拟机，容器中的应用都应该以前台执行，没有后台服务的概念
* `entrypoint`：入口点
  * 和 cmd 一样，指定容器启动的程序和参数
  * docker 命令行运行的参数会传给 Entrypoint
  *  实现启动主进程即容器前的准备工作：如脚本可以放到 entrypoint 中执行
* `env` 设置环境变量 `env`
  * `env`以键值对的格式设置环境变量，以方便后续的指令使用该变量
* `arg`构建参数 `arg`
  * 和 env 的效果一样，都是设置于环境变量
  * 此方式设置的环境变量在容器运行时是不会存在的
* `volume` 定义匿名卷
  * 容器运行时，尽量保持其存储层不发生写操作，对于数据库类需要保存动态数据的应用，数据库问价应该保存到卷中
  * 为防止用户忘记将动态文件所保存目录挂载为卷，在 dockerfile 中可以事先指定某些目录挂载为匿名卷
  * 即使用户不指定挂载，应用也可以正常运行，不会向容器存储层写入大量数据
  * `volume /data` 中的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 目录中写入的数据都不会进入容器存储层，从而保证了容器存储层的无状态化
  * 当然，也可以在运行时定义命名卷以覆盖在 dockerfile 中事先定义好的匿名卷：`docker run -d -v mydata:/data xxxx`
* `expose` 声明端口
  * 声明容器运行时容器提供服务端口，仅仅是一个端口号的声明，运行时并不会因此就开启该服务的端口
  * `-p <宿主端口>:<容器端口>` 将容器的对应端口服务公开给外界访问
* `workdir` 指定工作目录
  * 或曰当前目录，如果不存在，会自动创建
  * docker 中每一个 run 命令都是启动一个容器、执行命令、然后提交存储层文件变更。每一行 run 命令执行的环境不同，是两个完全不同的容器
  * 改变工作目录
* `user` 指定当前用户
  * 与 `workdir` 一样，都是改变环境状态并影响到以后的层
  * 改变之后层的执行 run、cmd、以及 entrypoint 这类命令的身份
  * 待切换的用户需要实现建立好，否则无法创建
* `healthcheck` 健康检查
  * 设置检查容器健康状态的命令
  * 当在一个镜像指定了该指令后，用其启动容器，初始状态会为 starting，在指令检查成功后变为 healthy，如果连续一定次数失败则变为 unhealthy
  * 和 cmd、entrypoint 一样，该命令只可以出现一次，如果多写了，只有最后一个有效
* `onbuild` 
  * 是一个特殊的指令，其后跟的是其他指令，如 run、copy 等。而这些指令在镜像构建时并不会执行，只有当以当前镜像为基础去构建下一级镜像时才会被执行

# 操作容器

* 容器是独立运行的一个或者一组应用，以及他们的运行态环境
* 虚拟机是模拟的一整套操作系统（提供了运行态环境和其他系统环境）即运行在上面的应用

## 启动

* 基于镜像新建容器并启动：`docker run -it ubuntu bash` 
  * 检查本地是否存在指定的镜像，不存在就从共有仓库下载
  * 利用镜像创建并启动一个容器
  * 分配一个文件系统，并在只读的镜像层外挂载一层可读写层
  * 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中
  * 从地址池配置一个 IP 给容器
  * 执行用户指定的应用程序
  * 执行完毕后容器被终止
* 已终止的容器重新启动： `docker container start`

## 后台运行

* `docker run -d ubuntu bash` 参数 `-d` 指明了以后台形式运行
* `docker container ls` 查看启动的容器
* `docker container logs [container ID or NAMES]` 获取容器日志信息

## 终止容器

* `docker container stop` 用于终止一个运行中的容器
* `docker container start`
* `docker container restart`

## 进入容器

* 使用 -d 参数时，容器启动后进入后台
* 当需要对容器进行操作的时候，可以使用 `docker exec`
* `docker run -dit ubuntu 
* `docker container ls`
* `docker exec -it [ID] bash`

## 导出和导入容器

* `docker ps -a` 查看容器
* `docker export [ID] > XXX.tar`：将容器快照导出到本地文件
* `docker import` 导入容器快照到本地进行库

## 删除容器

* `docker container rm [容器]` 删除一个处于终止状态的容器
* 若要对运行中的容器进行删除，需要添加参数 -f 。docker 会发送 sigkill 信号给容器
* `docker container prune` 用于删除所有处于终止状态的容器
* `docker container ls -a` 查看所有已创建的包括终止状态的容器

# Docker 数据管理

* 在容器中管理数据主要有两种方式：数据卷、挂载主机目录

## 数据卷

* 是一个特殊的目录，可供一个或多个容器使用
* 可以在容器之间共享和重用
* 对数据卷的修改会马上生效
* 对数据卷的更新不会影响到镜像
* 数据卷默认一直存在，即使容器被删除
* 推荐选择 `--amount`

### 操作数据卷

* 创建数据卷`docker volume create my-vol`
* 查看所有数据卷 `docker volume ls`
* 查看指定数据卷的信息：`docker volume inspect [ID]`
* 启动一个挂载数据卷的容器
  * `docker run -d -P --name web --amount source=my-vol target=/webapp training=/webapp python app.py`
  * --amount 标记将数据卷挂载到容器中
  * 一次 docker run 中可以挂载多个数据卷
  * 创建一个名为 web 的容器，并加载一个数据卷到容器的 /webapp 目录
* 查看数据卷的具体信息：`docker inspect web` 
* 删除数据卷
  * `docker volume rm my-vol`
  * 数据卷是用来持久化数据的，独立于容器。docker 在容器删除之后，不会自动删除数据卷
  * 无主的数据卷可能会占用很多空间，可以使用 `docker volume prune` 清理这些无主的数据卷

## 挂载主机目录和文件

* 推荐使用 `--amount` 参数进行挂载
*  挂载一个主机目录作为数据卷
  * `--amount` 标记可以指定挂载一个本地主机目录到容器中去
  * `docker run -d -P --name web --amount type=bind,source=/src/webapp,target=/opt/webapp training/webapp python app.py`
  * 将主机的 /src/webapp 目录加载到容器的 /opt/webapp 目录
* 挂载一个本地文件作为数据卷
  * `--amout` 也可以从主机挂载单个文件到容器中
  * `docker run --rm -it --amount type=bind,source=$HOME/.bash_history,target=/root/.bash_history ubuntu bash`

# 使用网络

* docker 允许外部访问容器和容器互联

## 外部访问容器

* 容器通过 -p 或者 -P 参数指定端口映射
* `-P` 标记时， docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口
* 如果本地主机的 49155 被映射到了容器的 5000 端口，此时可以访问本机的 49155 端口即可访问容器内 web 应用提供的界面
* `-p` 可以指定要映射的端口，且在一个指定端口上只可以绑定一个容器

### 映射所有接口地址

* 使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，会默认绑定本地所有接口上的所有地址
* `docker run -d -p 5000:5000 traning/webapp python app.py`

### 映射到指定地址的指定端口

* 使用 ip:hostPort:containerPort 格式指定映射使用一个特定的地址
* `docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py`

### 映射到指定地址的任意端口

* 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口
* `docker run -d -p 127.0.0.1::5000 training/webapp python app.py`

### 查看映射端口配置

* `docker port` 
* 容器有自己的内部网络和 IP 地址

## 容器互联

* 推荐将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 ` --link` 参数

### 新建网络

* `docker network create -d bridge my-net` 
* -d 指定网络类型：bridge 或者 overlay

### 连接容器

* 通过两个终端工具，运行 2 个容器并连接到刚才新建的 my-net 网络
  * `docker run -it --rm --name busybox1 --network my-net busybox sh`
  * `docker run -it --rm --name busybox2 --network my-net busybox sh`

# Docker Compose

* docker compose 是 docker 官方编排项目之一，负责快速在集群中部署分布式应用
* 定义和运行多个 docker 容器的应用
* dockerfile 文件可以定义一个单独的应用容器。但是很多情况下，一个应用需要多个容器之间的配合以完成任务，如数据库服务容器等
* compose 允许通过一个单独的 `docker-compose.yml` 模板文件来定义一组相关联的应用容器为一个项目
* compose 两个重要的概念
  * 服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例
  * 项目（project）：由一组关联的应用容器组成的一个完整的业务单元，在 docker-compose.yml 文件中定义

## 使用

* 一个项目 project 可以由多个服务 service（容器）关联组成
* 场景：一个web 网站，其中包含 web 应用和 redis 缓存

## docker compose 命令使用说明

* docker-compose 命令默认使用的模板是 docker-compose.yml 文件，可以通过 -f 指定非默认的文件
* `docker-compose -f | -p | -v | --x-networking | build | --pull | config | down | exec | help | images | kill | logs | help | pause | port | ps | pull | push | restart | rm | run` 等实现特定功能

## compose 模板文件

* 模板文件是 compose 的核心，涉及到很多关键字，默认为 docker-compose.yml，格式是 YAML 格式

> ` version: "3"` 
>
> `services:`
>
>     `webapp:`
>    
>      `image:example/web`
>    
>        `ports:`
>    
>          `- "80:80"`
>    
>      `volumes:`
>    
>           `- "/data"`	

* 每个服务必须通过 image 指令指定镜像或者 build 指令（dockerfile）等来自动构建生成镜像
* build 指令：使用此指令在 Dockerfile 文件中设置的选项（CMD、EXPOSE、VOLUME、ENV）将会自动被获取，无需要在 docker-compose.yml 文件中重复设置
  * 指定 Dockerfile 所在文件夹的路径（绝对路径或者相对于 docker-compose.yml 文件的路径）
  * context 指令指定 Dockerfile 所在文件夹的路径
  * dockerfile 指令指定 Dockerfile 文件名
  * arg 指令指定构建镜像时的变量
* command 指令：覆盖容器启动后默认执行的命令
* depends_on：解决容器的依赖、启动先后的问题
* tmpfs：挂载一个 tmpfs 文件系统到容器
* env_file：从文件中获取环境变量，可以是单独的文件路径或者列表
* environment：设置环境变量，数组或者字典格式
* expose：暴露端口，但不映射到宿主机，只被连接的服务访问
* healthcheck：检查容器是否健康运行
* image：指定为镜像名称或者镜像 ID。如果镜像本地不存在则 compose 将尝试拉取该镜像
* labels：为容器添加 Docker 元数据信息
* 读取变量：compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量  

# 安全

* 由内核的命名空间和控制组机制提供的容器内在安全
* docker 程序本身的抗攻击性
* 内核安全性的加强机制对容器安全性的影响

## 内核命名空间

* 当执行 docker run 启动容器时，在后台 docker 为容器创建了一个独立的命名空间和控制组集合
* 命名空间提供了最基础最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其他容器发现和影响
* 每个容器都有自己独有的网络栈，它们不能访问其他容器的 socket 或者接口。只有对主机系统做了相关设置，二者才可以交互联系

## 控制组

* 是 Linux 容器机制的另一个关键组件，负责实现资源的审计和限制
* 提供了很多有用的特性；确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO等资源；确保了当容器内的资源使用产生压力时不会连累主机
* 不负责隔离容器之间相互访问、处理数据和进程

## 服务端的防护

## 内核能力机制

* 提供细粒度的权限访问机制，既可以作用于进程上，也可以作用在文件上
* docker 启动的容器如果不需要使用 root 权限，可以只赋予其一部分内核使用能力，而禁用一些没必要的权限

## 其他安全特性

* docker 默认只启用了内核能力机制。还可以利用一些现有的机制增强其安全性或者自定义访问控制机制定制安全策略
* ‘容器加固’

# 底层实现

* Docker 底层核心技术包括 Linux 上的命名空间 namespace、控制组 cgroups、union 文件系统、容器格式
* 传统的虚拟机：在宿主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。实现了对资源的最完整封装，也会造成资源的浪费
* 让某些进程在彼此隔离的命名空间中运行，虽然彼此公用一个内核和某些运行时环境（系统命令和系统库），但是彼此之间却看不见，即为容器
* Namespace 实现权限的隔离控制、cgroups 实现资源的分配

## 基本架构

* C/S 架构，包括客户端和服务端（守护进程）。服务端接收和处理来自客户端的请求，二者可以运行在一个机器上，也可以通过 socket 或者 restful API 进行通信
* docker 服务端：守护进程在宿主机后台运行，等待接收来自客户端的请求
* docker 客户端：提供了一系列可执行的命令，通过这些命令实现和服务端的通信

## 命名空间

* 每个容器都有自己的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响
* pid 命名空间：不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同的 pid 
* net 命名空间：实现了网络隔离。每个 net 命名空间有独立的网络设备、IP 地址、路由表等。Docker 默认采用 veth 的方式将容器中的虚拟网卡同主机上的一个 docker 网桥连接在一起
* ipc 命名空间：容器中进程交互采用了 Linux 常见的进程交互法 IPC，包括了信号量、消息队列、共享内存等。容器的进程间交互实际上还是 host 上具有相同 pid 命名空间的进程间交互
* mnt 命名空间：允许不同命名空间的进程看到的文件结构不同
* uts 命名空间：允许每个容器拥有独立的 hostname 和 domain name，使其在网络上可以被视为一个独立的节点而非主机上的一个进程
* user 命名空间：每个容器可以拥有不同的用户组和组 id，即允许在容器内部使用容器内部的用户执行程序而非主机上的用户

## 控制组

* cgroups 是 Linux 内核的一个特性，主要用于对共享资源进行隔离、限制、审计等。通过对分配给容器的资源进行控制，从而避免了多个容器同时运行时对系统资源进行竞争。容器内存、CPU、磁盘IO等

## 联合文件系统

* union fs 是一种分层、轻量级且高性能的文件系统。支持对文件系统的修改作为一次提交来一层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下
* 是 docker 镜像的基础，镜像可以通过分层进行继承，基于基础镜像制作各种具体的应用镜像
* 不同 docker 容器可以共享一些基础的文件系统，再加上自己独有的改动层
* Overlay2 是 docker 默认的存储驱动

## 容器格式

* 采用 libcontainer 、runC、containerd 容器格式

# Linux 虚拟网络

* namespace、veth pair、bridge 说明和命令

