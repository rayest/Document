# Docker 简介 

* 基于 Linux 内核的 cgroup 、namespace 以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术
* 由于隔离的进程独立于宿主和其他的隔离进程，故而亦称其为容器
* 传统的虚拟化技术：虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需要的应用进程
* Docker 容器：容器内的应用进程直接运行于宿主机的内核，容器没有自己的内核，而且也没有进行硬件虚拟，因此更加轻便
* 更高效的利用系统资源：应用执行速度、内存损耗、文件存储速度都比传统虚拟机更高效。一个相同配置为主机，往往可以运行更多数量的应用
* 更快速的启动时间：由于直接寄宿于宿主内核，无需启动完整的操作系统，启动更加快速
* 一致的运行环境：Docker 镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性
* 持续交付和部署：通过 Dockerfile 进行镜像构建，并结合 CI 系统进行集成测试、自动部署

# 基本概念

* 三个基本概念：镜像、容器、仓库

## Docker 镜像

* 操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间
* Docker 镜像相当于是一个 root 文件系统。是一个特殊的文件系统，除了提供容器运行时所需要的程序、库、资源、配置等文件外，还包含了为运行时准备的一些配置参数，如匿名卷、环境变量、用户等
* 镜像不包含任何动态数据，且其内容在创建后不会改变

### 分层存储

* 镜像包含操作系统完整的 root 文件系统，体积表庞大。Docker 利用 Union FS 技术，将其设计为分层的技术架构。Docker 镜像是由多层文件系统组成
*  镜像构建时，会一层一层构建，前一层是后一层构建的基础。每一层构建成功之后都不会再改变，后一层的任何改变只发生在自己的一层

## Docker 容器

* 镜像和容器的关系就像面向对象中类和实例的关系。镜像是静态的定义，而容器是镜像运行时的实体。容器可以创建、启动、停止、删除和暂停的
* 容器的实质就是进程，但与直接在宿主机执行的进程不同，容器进程是运行于属于自己的独立的命名空间。因此容器拥有自己的 `root` 文件系统、网络配置、进程空间以及自己的用户 ID 空间
* 容器的进程时运行在一个隔离的环境中。使用时，如同在一个独立于宿主机的系统下操作
* 容器和镜像一样，使用分层技术。容器运行时，以镜像为基础层，在其上创建当前容器的存储层，该层为容器运行时读和写而准备
* 容器存储层的生命周期和容器一样，容器消亡时，容器也随之消亡。任何保存于容器存储层中的信息都会随着容器的删除而丢失
* 容器不应该向其存储层写入任何数据，容器存储层要保持无状态化。所有数据的写入要使用数据卷或者绑定宿主目录
* 数据卷的生命周期独立于容器。数据卷不会因为容器的消亡而消亡

## Docker Registry

* 镜像构建成功之后，可以在宿主机上运行。为了使其在其他机器上运行，需要一个集中的存储、分发镜像的服务，称之为  `Docker registry`
* 一个 `Docker registry` 可以包含多个仓库。每个仓库可以包含多个标签 `tag`，每个标签对应一个镜像，标签对应于该软件的各个版本
* 可以通过 `仓库名:标签` 的格式来指定具体版本的镜像。如 `ubuntu:16.04`

# 使用镜像

* 获取镜像：`docker pull` 从指定的镜像仓库获取镜像。下载时按照镜像的层文件逐层下载
* 运行容器：`docker run` 通过下载或者自己创建的镜像，以此为基础启动并运行一个容器
* 列出镜像：`docker image ls` 列出已经下载或者创建的所有镜像。列出的每一个镜像的吸管吸信息中都包含：`仓库名`，`标签`，`镜像ID`，`创建时间`，`所占用的空间`
* 镜像体积：镜像下载之后，其体积为该镜像展开后的各层所占用的空间总和，是未经压缩的大小。列表中所有镜像体积总和并不是所有镜像实际硬盘消耗，因为docker 镜像是分层存储结构，可以继承和复用，不同镜像可以使用相同的基础镜像而拥有共同的层，而相同的层只需要保存一份即可。通过命令 `docker system df` 可以查看镜像、容器和数据卷占用的空间
* 虚悬镜像：镜像列表中一个特殊的镜像，没有仓库名、标签，均为 `<none>`。没有实际意义，通过命令 `docker image prune`删除
* 中间层镜像：用于加速镜像构建、重复利用资源。在使用一段时间后，会出现一些依赖的中间层镜像。默认的 `docker image ls` 只会显示顶层镜像。`docker image ls -a` 可以显示包括中间层镜像在内的所有镜像。这里的=出现的一些无标签的虚悬镜像是其他镜像依赖的中间层镜像，不能删除
* 列出部分镜像：`docker image ls ubuntu` 可以列出指定为 `ubuntu` 的所有镜像 

## 删除本地镜像

* `docker image rm <镜像>` ：可以删除一个或者多个指定的镜像
* 可以通过镜像名、镜像端ID、镜像长ID、镜像摘要删除指定的镜像
* docker 在删除镜像时，即为删除某个标签的镜像。
  * 所以首先需要取消要删除镜像的标签，如果一个镜像有多个标签，当删除其中一个标签对应的镜像时，仅仅将该标签取消 `untagged`，实际上并不真正删除镜像 `deleted`
  * 除此之外，如果镜像的某一层为其他镜像所依赖，则只删除其它层，该依赖层不能删除
  * 删除镜像时，如果有用该镜像启动的容器正在运行，也无法删除。因为容器依赖该镜像，先删除容器再删除镜像

## 利用 commit 理解镜像构成

* `docker run --name webserver -d -p 80:80 nginx`：用 `nginx` 镜像启动容器，名为 `webserver`，并且映射了端口 `80`。启动成功之后，可以通过 IP 和端口访问
* `docker run -it ubuntu bash` 命令也可以进入由 ubuntu 镜像启动的容器 shell。
* 可以通过容器内部的 shell 对容器文件进行修改，修改的任何数据都会记录于容器存储层中。再通过 `docker commit` 将容器的存储层保存下来，形成新的镜像
* docker 修改的数据都是在当前层进行修改，之前层的文件不会改变。通过该种方式会让镜像更加臃肿

## 使用 Dockerfile 定制镜像

* 该文件由一条条指令组成，每一条指令构建一层。每一条指令的内容描述了改层该如何构建
* `from`：指定基础镜像
  * 定制镜像是以一个镜像为基础，在其上进行定制。from 就是指定一个基础镜像，必须为 dockerfile 的第一条指令
  * 特殊的 `from scratch`，以 scratch 为基础镜像意味着不以任何镜像为基础，接下来所写的指令将作为进行第一层而使用
* `run`：指令是用于执行命令行命令的，最为常用
  * shell 格式（如直接在命令行输入一样）
  * exec 格式（像是函数调用中的格式）
  * 每个 run 指令的行为都会新建立一层，并执行这些 run 命令，执行结束后，commit 这一层的修改，构成新镜像
  * 在编写 run 指令时需要考虑是否需要在一层实现，如果仅实现一个目的，可以通过 `&&` 符号将多个 run 命令简化为一个，以使构建层数尽可能的少，减少不必要的臃肿
  * 在对每一层进行构建后，需要清理删除不必要的文件，免得镜像过于臃肿
*  构建镜像：`docker build` 可以指定最终镜像的名称和标签，构建成功之后，可以运行
* 进行构建上下文（context）：`docker build ` 命令最后有一个 `.`，表示当前目录，用于指定上下文路径
  * docker 运行时分为 docker 引擎（服务端守护进程）和客户端工具
  * docker 引擎提供了一系列 REST API，docker 命令这样的客户端工具通过这组 API 与 Docker 引擎交互，完成各种功能。表面上看是在本地执行各种 docker 功能，实际上是通过`远程过程调用` 在服务端完成这些工作的。（类似于 redis 及其客户端）
  * 在进行镜像构建的时候，并非所有的定制都是通过 run 命令实现的，还有其他指令以实现使用本地文件
  * docker build 构建镜像时，并非在本地构建，而是在服务端实现的，即在 docker 引擎中构建。为使服务器获得本地文件，引入了上下文概念
  * 构建时，用户会指定构建镜像的上下文路径。当 docker build 得知该路径后，会将路径下的所有文件打包，然后上传给 docker 引擎。docker 引擎获得该上下文包后，展开就会获得构建镜像所需要的一切文件

## Dockerfile 指令

* `copy`
  * 将构建上下文目录中的文件（源文件）复制到新的一层镜像内（目标路径）
  * 如果目标路径不存在，复制文件前会自动创建
  * 源文件的各种数据都会保留，如执行权限和文件变更时间等
* `add`： 是更高级的复制文件，但是仍更推荐使用 copy 指令
* `cmd`
  * 用于指定默认的容器主进程的启动命令的。推荐使用 exec 格式的命令
  * docker 作为容器即进程，在启动的时候，需要指定运行所需要的参数和程序
  * docker 不是虚拟机，容器中的应用都应该以前台执行，没有后台服务的概念
* `entrypoint`：入口点
  * 和 cmd 一样，指定容器启动的程序和参数
  * docker 命令行运行的参数会传给 Entrypoint
  *  实现启动主进程即容器前的准备工作：如脚本可以放到 entrypoint 中执行
* `env` 设置环境变量 `env`
  * `env`以键值对的格式设置环境变量，以方便后续的指令使用该变量
* `arg`构建参数 `arg`
  * 和 env 的效果一样，都是设置于环境变量
  * 此方式设置的环境变量在容器运行时是不会存在的
* `volume` 定义匿名卷
  * 容器运行时，尽量保持其存储层不发生写操作，对于数据库类需要保存动态数据的应用，数据库问价应该保存到卷中
  * 为防止用户忘记将动态文件所保存目录挂载为卷，在 dockerfile 中可以事先指定某些目录挂载为匿名卷
  * 即使用户不指定挂载，应用也可以正常运行，不会向容器存储层写入大量数据
  * `volume /data` 中的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 目录中写入的数据都不会进入容器存储层，从而保证了容器存储层的无状态化
  * 当然，也可以在运行时定义命名卷以覆盖在 dockerfile 中事先定义好的匿名卷：`docker run -d -v mydata:/data xxxx`
* `expose` 声明端口
  * 声明容器运行时容器提供服务端口，仅仅是一个端口号的声明，运行时并不会因此就开启该服务的端口
  * `-p <宿主端口>:<容器端口>` 将容器的对应端口服务公开给外界访问
* `workdir` 指定工作目录
  * 或曰当前目录，如果不存在，会自动创建
  * docker 中每一个 run 命令都是启动一个容器、执行命令、然后提交存储层文件变更。每一行 run 命令执行的环境不同，是两个完全不同的容器
  * 改变工作目录
* `user` 指定当前用户
  * 与 `workdir` 一样，都是改变环境状态并影响到以后的层
  * 改变之后层的执行 run、cmd、以及 entrypoint 这类命令的身份
  * 待切换的用户需要实现建立好，否则无法创建
* `healthcheck` 健康检查
  * 设置检查容器健康状态的命令
  * 当在一个镜像指定了该指令后，用其启动容器，初始状态会为 starting，在指令检查成功后变为 healthy，如果连续一定次数失败则变为 unhealthy
  * 和 cmd、entrypoint 一样，该命令只可以出现一次，如果多写了，只有最后一个有效
* `onbuild` 
  * 是一个特殊的指令，其后跟的是其他指令，如 run、copy 等。而这些指令在镜像构建时并不会执行，只有当以当前镜像为基础去构建下一级镜像时才会被执行