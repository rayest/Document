# InnoDB

> 存储引擎是基于表的，而非数据库

## 体系架构

* InnoDB 有多个内存块，组成了一个大的内存池
  * 维护进程或者线程需要访问的内部数据结构
  * 缓存磁盘上的数据 
  * …...

### 后台线程

* 单进程多线程：不同的后台线程处理不同的任务
* Master Thread
  * 异步刷新缓存中的数据到磁盘：保证数据的一致性
    * 脏页的刷新
    * 合并插入缓存
    * undo 页的回收
* IO Thread
  * InnoDB 使用 AIO 处理 IO 请求，IO Thread 负责这些 IO 请求的回调
* Purge Thread
  * 事务提交后，回收已经使用并分配的 undo 页
  * 该线程离散地读取 undo 页
* Page Cleaner Thread
  * 处理脏页

### 内存

> 对数据管理是基于页进行的

* 缓存池
  * 基于磁盘的数据库通过缓存池技术提高性能
  * 是一块内存区域
  * 以一定频率将缓存池中页的数据刷新到磁盘：checkpoint 机制
  * 缓存的数据页类型：
    * 索引页、数据页、undo 页、插入缓存、自适应哈希索引 …...
* LRU List
  * 缓存的管理：最近最少使用原则：Latest Recent Used
  * 频繁使用的在列表前端，最少使用的在列表后端。当缓存池中不能存放读取到的数据时，将首先释放列表尾部的页
  * midpoint：约为列表长度的 5/8 处，新读取的页插入的位置。
* Free List
  * 管理已经读取的页
* Flush List
  * 管理将页刷新到磁盘
  * 脏页列表
  * 脏页同时还存在于 LRU 列表中
* 重做日志缓冲
  * InnoDB 将重做日志信息放到该缓冲区，再按一定频率将其刷新到重做日志文件中

## CheckPoint 技术

> 缩短数据库恢复时间

* 数据库宕机后，只需要恢复 checkpoint 之后的页数据，之前的页已经刷新到磁盘了

> 缓冲池不够用时，将脏页刷新到磁盘：

* 根据 LRU 算法，溢出的页如果是脏页，将强制执行 checkpoint，刷新到磁盘

> 重做日志不够用时，刷新脏页

## Master Thread 工作方式

## InnoDB 关键特性

### 插入缓存（Insert Buffer）

> 和数据页一样，是物理页的组成部分。提高插入性能。

* 条件
  * 索引是辅助索引
  * 索引不是唯一的

### 两次写

> 提高可靠性

* 在重做日志之前，需要一个页的副本，当写失效时 ( 如数据库宕机，正在执行写的页遭到破坏 )，通过该副本恢复本来的页，再进行日志重做 —— double write
* 2个组成部分
  * 内存中的 double write buffer，大小 2M
  * 磁盘上共享表空间中连续的128个页 ( 2 个区 )，大小 2M
* 原理
  * 当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的 double write buffer。
  * 接着从 double write buffer 两次写入磁盘共享表空间中，每次写入1MB
  * 同步磁盘
  * 将 double write buffer 中的页写入各个表空间文件

### 自适应哈希索引

* InnoDB 存储引擎会监控对表上索引的查找，如果监控到建立哈希索引可以提高性能，则自动建立哈希索引 —— 自适应
* 根据访问的频率和模式为某些页建立哈希索引
* 由 InnoDB 存储引擎控制

### 异步 IO

### 刷新邻接页

# 文件

> 参数文件、日志文件、套接字文件、pid 文件、表结构定义文件：略

## InnoDB 存储引擎文件

* 表空间文件
* 重做日志文件

# 表

* 在 InnoDB 存储引擎中，每张表都有主键。如果在创建表的时候，没有显式地定义主键（primary key）：

  * 如果有非空的唯一索引（unique not null），则该列为主键

  * 否则：自动创建一个6字节大小的指针

## 存储结构

> 所有数据都存放在一个空间中 ( 表空间 )：段 --> 区 --> 页 ( 块 )

### 表空间

* 默认一个公共表空间，所有的数据存于此，曰：ibdata1
* 若启用 innodb_file_per_table：则每张表的数据可以单独放到一个表空间内
  * 此时，每张表空间存放的只是数据、索引、插入缓存
  * 其他信息还是在共享表空间内

### 段

* 数据段、索引段、回滚段、......
* 表空间由分散的页和段组成：因为有些对象没有段

### 区

* 由 64 个连续的页组成，每个页 16 KB，每个区 1 MB
* 大多数的段每次最多可以申请 4 个区

### 页

* 是 InnoDB存储引擎最小的管理单位

### 行

* InnoDB 是面向行的
* 每个页最多存放 7992 行记录：16KB / 2

## 行记录格式

> Compact、Redundant

### Compact

* 高效存储数据：如果一个页中存储的数据越多，性能越好
* MySQL 5.0 时引入

### Redundant

* MySQL 5.0 之前引入

### 行溢出数据

* 某些数据可以不记录在数据页中，而是作为行溢出数据
* BLOB、LOB、VARCHAR 等可能存储大对象类型的类型可以将数据放在溢出页面

### ......

## 页结构

### File header

> 该页的校验和、表空间中该页的偏移量、当前页的上一页和下一页、页的类型、表空间ID

### Page header

* 页目录中的槽数
* 堆中第一个记录的指针
* 堆中的记录数
* 指向空闲列表的首指针
* 已删除记录的字节数
* 最后插入记录的位置
* 最后插入的方向
* 一个方向连续插入的数量
* 该页中记录的数量
* 当前页的最大事务ID
* 当前页所在的索引树的位置
* 当前页所属的索引ID
* ......

### Infimum 和 Supremum 记录

> 每个数据页有两个虚拟的行记录，以限定记录的边界。在页创建时被建立，且不会被删除

* Infimum
  * 记录比该页中任何主键值都小的值
* Supremum
  * 记录比任何可能的值都大的值

### User records

> 实际存储的行记录内容

### Free Space

> 空闲空间，链表结构。当一条记录被删除时，该空间会被加入空闲空间中

### Page Directory

* 页目录存放了记录的相对位置，而非偏移量。这些记录指针又称为槽或者目录槽
* 槽是稀疏目录，一个槽可能属于多个记录。最少4条，最多8条
* 槽中记录按照键的顺序存放

## 约束

### 数据完整性

* 实体完整性

> 保证表中有一个主键：primary key 或者 unique key

* 域完整性

> 保证数据的值满足特定的条件：合适的数据类型、外键约束、DEFAULT 约束

* 参照完整性

> 保证两个表之间的关系，外键实现

### InnoDB 的 4 种约束

* Primary Key
* Unique Key
* Foreign Key
* Default
* Not Null

### 约束和索引的区别

* 约束是逻辑概念，以保证数据完整性
* 索引是一个数据结构，有逻辑上的概念，也通过物理方式进行实际的存储

### 触发器

* 在 INSERT、DELETE、UPDATE 命令之前或者之后进行自动调用 SQL 命令或者存储过程，实现完整性约束

### 外键

> 尽量在代码层实现

## 视图

> 虚表，没有物理表现形式

### 作用

* 被用作为一个抽象装置，起到安全层的作用
* 也可以通过视图的定义更新基本表

### 物化视图

* MySQL 本身不支持物化视图，但是通过某些机制实现物化视图的功能

## 分区表

### 概述

* 将表或者索引物分解为更小的部分
* 仅支持水平分区：同一张表中的不同行记录被分到不同的物理文件中
* 局部分区索引：一个分区中既存放了数据，也存放了索引
* 如果表中存在主键或者唯一索引时，分区列必须是唯一索引的一部分

### Range 分区

* 创建表时，可以通过建表语句创建 Range 分区。该分区方式指定了每个分区应该存放的数据范围
* 指定的分区数量有多少，就会有多少物理文件存储对应范围的数据，而不是一个单独的表空间文件
* 需要插入的数据，依据分区列进行对应的插入
* 当插入了一个未在分区中定义的数据时，MySQL 会抛出异常
* 该分区主要用于日期列的分区，以便于能根据特定的分区查询、删除、修改某段日期内的数据

### List 分区

* 类似于 Range 分区，只是分区列的值是离散的，而非连续的
* 各分区内的数据是指定的一个个具体值（1，4，6，8），而不是值范围（1 ~ 10）

### Hash 分区

* 将需要插入的数据随机地均匀分布到定义好的各个分区中，以保证各分区内的数据数量大致上是一样的
* 在创建表时需要自定义 hash 函数，确定 hash 规则

### Key 分区

* 使用 MySQL 内置函数定义分区规则，内置的 hash 函数

### Columns 分区

* 以上 4 种方式的分区条件必须是整数，否则的话，应该通过某些函数转化为整数
* 支持的分区条件类型
  * 所有的整型：FLOAT 和 DOUBLE 不支持
  * 日期：DATE 和 DATETIME，其余不支持
  * 字符串：BLOB 和 TEXT 不支持
* 日期类型可以直接使用 COLUMNS (如，less than ‘2010-08-08’)

### 子分区

* 在分区的基础上再进行分区，或曰：复合分区
* 在 Range、List 分区上再进行 hash 或者 Key 分区

### 分区中的 NULL 值

> Null 值作为分区列时

* Range 分区，将插入的 null 值放在最左边的分区
* List 分区，需要显示指定哪个分区中存放 NULL 值
* HASH 和 KEY 分区，分区函数将含有 NULL 值的记录返回为 0

### 分区和性能

* OLTP：在线事务处理
  * 场景：用户应用
  * 需要小心分区，分区性能未必好
* OLAP：在线分析处理
  * 场景：后台管理系统
  * 如果数据庞大，大部分情况需要分区，性能提升显著

# 索引和算法

## 概述

> InnoDB 两种常见的索引：B+树索引、哈希索引

* B+树索引
  * 即为传统意义上的索引，最为经常使用，也最为有效
  * 类似于二叉树，通过键值对快速找到数据
  * B 不是二叉 binary，而是平衡 balance
  * 由平衡二叉树演化而来，但不是二叉树
* 注意：通过该类索引，不能直接找到给定键值对的具体行，而是被查找数据行所在的页，然后把页读入内存，再在内存中进行查找，最终找到具体数据所在的行

## 平衡二叉树

### 二叉树

* 左子树的键小于根的键，根的键小于右子树：left < root < right
* 可以通过中序遍历，迅速查找出数据

### B+树

* 所有的记录节点都是按照键的大小顺序放在同一层的叶子节点上，各叶子节点通过指针连接
* 其余，暂略

### B+树索引

* 在数据库中的高度一般都在 2 ~ 3 层。因此，查找到一条记录需要 2 ~ 3 次的 IO
* 聚集索引
  * 按照每张表的主键构造一颗 B+ 树，并且叶节点存放整张表的行记录
  * 每张表只能有一个聚集索引
* 辅助索引

### B+树索引的使用

- 当访问表中很少一部分数据时，考虑使用 B+ 树索引，高选择性

  - 如：id，username，不会有重复出现，选择性高
- 但是，当使用高选择性的字段，选择出的行数据过多，占据了表中的大部分数据时，不使用

  - 如：integer 类型的 id 范围查询
- 顺序读

  - 磁盘：顺序读取磁盘上的块，性能高于磁盘的随机读
  - 数据库：根据索引的叶节点数据就能顺序读取所需的行数据
  - 逻辑上是顺序读取，在物理磁盘上，仍有可能是随机读
  - 物理磁盘数据存储相对而言比较顺序，因为是根据区来管理的，而区是 64 个连续的页
- 随机读

  - 磁盘：访问的块是不连续的，需要磁头不断移动。传统机械磁盘的瓶颈
  - 数据库：需要根据辅助索引叶节点中的主键查找实际行数据
- 预读取

  - 通过一次 IO 请求将多个页数据预读到缓冲池中，并且估计预读取的多个页数据会立刻被访问
  - 传统的 IO 请求每次仅读取一个页
  - 提高了读取的性能
  - 2 个预读取方式
    - 随机预读取
      - 当一个区 (64个页) 中有13个页在缓冲区中，并在LRU列表的前端，则 InnoDB 将这个区中剩余的页预读取到缓冲区
    - 线性预读取
      - 如果一个区的24个页都被顺序访问了，则 InnoDB 会读取下一个区的所有项
- 辅助索引的优化使用
  - 辅助索引的叶节点包含主键，但不包含完整的行信息
  - InnoDB 先从辅助索引判断是否能得到所需要的数据
- 联合索引
  - 对表上的多个列添加索引

### 哈希算法

* 哈希表（散列表），改进于直接寻址表（数组）
* 数组和链表
* 碰撞：哈希函数结果映射到同一个槽
* 解决碰撞：链地址法，把散列到同一个槽的所有元素放在一个链表中

# 锁

> 管理对共享资源的并发访问，在行级别上对表加锁

## InnoDB 中的锁

### 锁类型

* 共享锁（S Lock）
  * 允许事务读一行数据
* 排他锁（X Lock）
  * 允许事务删除或者更新一行数据

> 当一个事务已经获取到了行 r 的共享锁，另外事务可以立即获取到行 r 的共享锁：锁兼容
>
> 另外的事务想获取行 r 的排它锁，必须要等到事务释放行 r 上的共享锁

* 意向锁

  > 额外的锁方式。支持在不同粒度进行加锁操作。
  >
  > 不会阻塞除全表意外的任何请求：因为 InnoDB 支持的是行级别的锁

  * 意向共享锁
    * 事务想要获得一个表中某几行的共享锁
  * 意向排它锁
    * 事务想要获得一个表中的几行排它锁

### 一致性的非锁定读操作

* InnoDB 通过行多版本控制的方式来读取当前执行时间数据库中行的数据，如果读取的行正在执行 DELETE、UPDATE 的操作。此时，读操作不会因此而等待行上锁的释放，InnoDB 会读取行的一个快照数据
* 此时的快照数据是指该行之前版本的数据，通过 undo 段实现
* 是默认的读取方式，读取不会占用和等待表上的锁。在默认的事务隔离级别下
* 不同的事务隔离级别读取的方式不同，读取的未必是一致性读
* MVCC 是指多版本并发控制。一个行可能具有多个不同历史版本，每一个版本都代表之前的数据。因此，一个行可能有多个快照数据
* Read committed
  * 使用非锁定的一致性读
  * 总是读取被锁定行最新的一份快照数据
* Repeatable Read
  * 使用非锁定的一致性读
  * 总是读取事务开始时的行快照数据

 ### SELECT ... FOR UPDATE 和 SELECT ... LOCK IN SHRAE MODE

* 在使用默认的事务隔离级别下，行读取使用一致性费锁定读。某些情况下，需要对读操作进行加锁
* SELECT ... FOR UPDATE
  * 对读取的行记录加 X 锁，其他事务想在该行上加任何锁，都会被阻塞
* SELECT ... LOCK IN SHRAE MODE
  * 对读取的上记录加 S 锁，其他事务可以向该行上加 S 锁，如果加 X 锁，会被阻塞

### 自增长和锁

* 自增长
  * 较多选择的主键方式
  * InnoDB 对含有自增长值的表都有一个自增长计数器，当该表有值插入时，会统计计数器的最大值
  * 插入操作会依据该自增长计数器的值，对其加1，并赋予自增长列 ( 这种实现方式称为：Auto-inc Locking )
  * 是一种特殊的锁机制，为了提高性能，该锁不是在一个事务完成之后释放，而是在完成对自增长值插入的SQL语句后立即释放
  * InnoDB中，必须是索引，并且是索引的第一个列

### 外键和锁

* 用于引用完整性的约束检查
* 如果没有显式地对外键列加索引，InnoDB 会自动对其加索引，以避免表锁
* 对于外键的插入或者更新，首先需要查询父表中的记录，对父表的操作会主动对其加 S 锁，而不能是使用一致性的非锁定读，使用 SELECT ... LOCK IN SHRAE MODE 方式

## 锁的算法

> 3 种行锁的算法。InnoDB 会自动选择最小的算法模型

### Record Lock

* 单个行记录上的锁。总是会锁住索引记录，如果没有索引，则锁定隐式的主键

  > 如：select * from t where a = 7 lock in share mode; 且 a 是主键

  * 此时，是对单个值的索引查询，不需要用到间隙锁
  * 在同一个事务的另一个会话内，如果对表 t 进行插入操作，则大于和小于 7 值的插入都会立即执行，无需等待

### Gap Lock

* 间隙锁，锁住一个范围，但不包括记录本身

### Next-Key Lock

* 是 Record Lock 和 Gap Lock 的结合。锁定一个范围，且包括记录本身

* InnoDB 默认对于行的查询都是这种锁定算法（因为默认的隔离级别是 Repeatable Read）

  > 如：select * from t where a < 6 lock in share mode; 且 a 是主键  

  * 此时，对行读操作加了S 锁，并且锁定的范围是 (-∞, 6]，包括 6 在内
  * 在同一个事务的另一个会话内，如果对表 t 进行插入操作，则小于等于 6 值的插入都会被阻塞

## 锁问题

> 好处：实现了事务隔离性的要求、是之可以并发工作
>
> 问题：3 种

### 丢失更新

* 多个事务并发执行，对同一条记录的多个更新操作，事务提交后，只有最后一条有效
* 解决：将事务改为串行操作，加 X 排他锁

### 脏读

* 脏页：缓冲池中已经被修改的数据页，还未刷新到磁盘。读取是正常的
* 脏数据：缓冲池中被修改的数据，还未提交。如果读取到则是非正常的，一个事务读取到了另一个事务的数据，违反了事务的隔离性
* 脏读：一个事务读取到了另一个事务未提交的数据
* 发生的条件是，事务的隔离级别被设置为 Read uncommitted

### 不可重复读

* 在一个事务内多次读取同一数据
* 在第一个事务读取该数据还未结束时，第二个事务也访问该数据，并对该数据进行修改。则第一个事务如果两次读取该数据，则结果是不一样的，即为不可重复读 ( 无法读取到之前读到的数据 ）
* 与脏读的区别：读到的是已经提交的数据，违反了事务一致性
* 事务隔离级别是 Read Committed 时允许不可重复读
* 或曰：幻读
* InnoDB 默认的事务隔离级别下采用的是 Next-Key Lock 算法，会锁住索引所在的一个范围，锁住对该范围内的插入操作，避免了不可重复读现象

## 阻塞

* 当事务开始访问行记录等资源的时候，会申请资源上的锁，待资源访问或者修改结束后，释放锁
* 锁的申请和释放需要通过特定的函数实现：mutex_enter  和 mutex_exit 
* 当资源被一个事务占用后，其他事务想要申请访问时，就会被阻塞

# 事务

> ACID 四个特性

## 概述

* 原子性：事务中的任何SQL执行失败，所有已经执行的SQL都要撤销，数据库状态需要退回到执行事务之前的状态
* 一致性：事务将数据库状态从一种状态转移到下一种一致的状态。事务开始以前和结束以后，数据库的完整性约束没有被破坏
* 隔离性：一个事务的影响在该事务提交之前对其他事务不可见。通过锁来实现
* 持久性：事务一旦提交，其结果就是永久的，不可更改

## 事务的实现

> 隔离性由事务的锁实现
>
> 其余3个特性由数据库的 redo 和 undo 实现

### redo

* 在 InnoDB 存储引擎中，事务的日志通过重做日志文件 ( redo )和 InnoDB 的日志缓冲实现
* 事务开始时，会记录该事务的一个日志序列号 ( LSN )
* 事务执行时，会往 InnoDB 的日志缓冲里插入事务日志
* 事务提交时，必须将该缓冲日志写如磁盘
* 即：写数据前，先写日志，曰为预写日志方式
* 所以，磁盘上的数据页和内存缓冲池中的数据页是不同步的，对于内存缓冲池中页的修改，先是写入重做日志文件，再写入磁盘
* redo 记录存放在重做日志记录文件中

### undo

* 事务有时候需要撤销，此时就需要 undo，与 redo 相反
* 对数据库进行修改时，既会产生 redo，也有 undo。
* 在事务执行失败的时候，可以利用 undo 信息将数据回滚到修改之前的样子
* undo 信息放在数据库内部的一个特殊段中，曰为 undo 段，在共享表空间中
* 所有的 undo 操作都是在逻辑上恢复到原来的样子，所有修改都只是被逻辑地取消。人不能两次踏进同一条河流

## 事务控制语句

> 事务控制语句说明和解释

* start transaction 或 begin：显式地开启一个事务
* commit 或者 commit work：提交事务，使修改得到持久化
* rollback 或者 rollback work：回滚事务，撤销正在进行的未提交的修改
* savepoint：在事务过程中创建保存点，一个事务可以有多个
* release savepoint：删除事务的保存点
* rollback to savepoint：把事务回滚到保存点，而不回滚在此之前的任何工作
* set transaction：设置事务的隔离级别
  * InnoDB 有 4 种隔离级别；Read uncommitted、Read committed、Repeatable Read、serializable

## 隐式提交的SQL

* DDL 语句：Alter ……，Create ……，Drop ……, Upgrade ……, Rename ……, Truncate ……, 等等

## 对事务操作的统计

* QPS：每秒请求书
* TPS：每秒事务处理的能力

## 事务的隔离级别

* InnoDB 默认的事务隔离级别：Repeatable Read。同时默认使用 Next-key Lock 锁，以避免幻读
* 隔离级别越低，事务请求的锁越少，保持锁的时间就越少
* 在 serializable 事务隔离级别下，InnoDB 会在每个 select 语句后面加上 lock in share mode，即为每个读操作加一个共享锁，读操作占用了锁，一致性非锁定读不再予以支持，主要用在 InnoDB 存储引擎的分布式事务

