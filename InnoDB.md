#InnoDB

> 存储引擎是基于表的，而非数据库

##体系架构

* InnoDB 有多个内存块，组成了一个大的内存池
  * 维护进程或者线程需要访问的内部数据结构
  * 缓存磁盘上的数据 
  * …...

### 后台线程

* 单进程多线程：不同的后台线程处理不同的任务
* Master Thread
  * 异步刷新缓存中的数据到磁盘：保证数据的一致性
    * 脏页的刷新
    * 合并插入缓存
    * undo 页的回收
* IO Thread
  * InnoDB 使用 AIO 处理 IO 请求，IO Thread 负责这些 IO 请求的回调
* Purge Thread
  * 事务提交后，回收已经使用并分配的 undo 页
  * 该线程离散地读取 undo 页
* Page Cleaner Thread
  * 处理脏页

### 内存

> 对数据管理是基于页进行的

* 缓存池
  * 基于磁盘的数据库通过缓存池技术提高性能
  * 是一块内存区域
  * 以一定频率将缓存池中页的数据刷新到磁盘：checkpoint 机制
  * 缓存的数据页类型：
    * 索引页、数据页、undo 页、插入缓存、自适应哈希索引 …...
* LRU List
  * 缓存的管理：最近最少使用原则：Latest Recent Used
  * 频繁使用的在列表前端，最少使用的在列表后端。当缓存池中不能存放读取到的数据时，将首先释放列表尾部的页
  * midpoint：约为列表长度的 5/8 处，新读取的页插入的位置。
* Free List
  * 管理已经读取的页
* Flush List
  * 管理将页刷新到磁盘
  * 脏页列表
  * 脏页同时还存在于 LRU 列表中
* 重做日志缓冲
  * InnoDB 将重做日志信息放到该缓冲区，再按一定频率将其刷新到重做日志文件中

##CheckPoint 技术

> 缩短数据库恢复时间

* 数据库宕机后，只需要恢复 checkpoint 之后的页数据，之前的页已经刷新到磁盘了

> 缓冲池不够用时，将脏页刷新到磁盘：

* 根据 LRU 算法，溢出的页如果是脏页，将强制执行 checkpoint，刷新到磁盘

> 重做日志不够用时，刷新脏页

## Master Thread 工作方式

## InnoDB 关键特性

### 插入缓存（Insert Buffer）

### 两次写

### 自适应哈希索引

###异步 IO

### 刷新邻接页

