# InnoDB

> 存储引擎是基于表的，而非数据库

## 体系架构

* InnoDB 有多个内存块，组成了一个大的内存池
  * 维护进程或者线程需要访问的内部数据结构
  * 缓存磁盘上的数据 
  * …...

### 后台线程

* 单进程多线程：不同的后台线程处理不同的任务
* Master Thread
  * 异步刷新缓存中的数据到磁盘：保证数据的一致性
    * 脏页的刷新
    * 合并插入缓存
    * undo 页的回收
* IO Thread
  * InnoDB 使用 AIO 处理 IO 请求，IO Thread 负责这些 IO 请求的回调
* Purge Thread
  * 事务提交后，回收已经使用并分配的 undo 页
  * 该线程离散地读取 undo 页
* Page Cleaner Thread
  * 处理脏页

### 内存

> 对数据管理是基于页进行的

* 缓存池
  * 基于磁盘的数据库通过缓存池技术提高性能
  * 是一块内存区域
  * 以一定频率将缓存池中页的数据刷新到磁盘：checkpoint 机制
  * 缓存的数据页类型：
    * 索引页、数据页、undo 页、插入缓存、自适应哈希索引 …...
* LRU List
  * 缓存的管理：最近最少使用原则：Latest Recent Used
  * 频繁使用的在列表前端，最少使用的在列表后端。当缓存池中不能存放读取到的数据时，将首先释放列表尾部的页
  * midpoint：约为列表长度的 5/8 处，新读取的页插入的位置。
* Free List
  * 管理已经读取的页
* Flush List
  * 管理将页刷新到磁盘
  * 脏页列表
  * 脏页同时还存在于 LRU 列表中
* 重做日志缓冲
  * InnoDB 将重做日志信息放到该缓冲区，再按一定频率将其刷新到重做日志文件中

## CheckPoint 技术

> 缩短数据库恢复时间

* 数据库宕机后，只需要恢复 checkpoint 之后的页数据，之前的页已经刷新到磁盘了

> 缓冲池不够用时，将脏页刷新到磁盘：

* 根据 LRU 算法，溢出的页如果是脏页，将强制执行 checkpoint，刷新到磁盘

> 重做日志不够用时，刷新脏页

## Master Thread 工作方式

## InnoDB 关键特性

### 插入缓存（Insert Buffer）

> 和数据页一样，是物理页的组成部分。提高插入性能。

* 条件
  * 索引是辅助索引
  * 索引不是唯一的

### 两次写

> 提高可靠性

* 在重做日志之前，需要一个页的副本，当写失效时 ( 如数据库宕机，正在执行写的页遭到破坏 )，通过该副本恢复本来的页，再进行日志重做 —— double write
* 2个组成部分
  * 内存中的 double write buffer，大小 2M
  * 磁盘上共享表空间中连续的128个页 ( 2 个区 )，大小 2M
* 原理
  * 当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的 double write buffer。
  * 接着从 double write buffer 两次写入磁盘共享表空间中，每次写入1MB
  * 同步磁盘
  * 将 double write buffer 中的页写入各个表空间文件

### 自适应哈希索引

* InnoDB 存储引擎会监控对表上索引的查找，如果监控到建立哈希索引可以提高性能，则自动建立哈希索引 —— 自适应
* 根据访问的频率和模式为某些页建立哈希索引
* 由 InnoDB 存储引擎控制

### 异步 IO

### 刷新邻接页

# 文件

> 参数文件、日志文件、套接字文件、pid 文件、表结构定义文件：略

## InnoDB 存储引擎文件

* 表空间文件
* 重做日志文件

# 表

* 在 InnoDB 存储引擎中，每张表都有主键。如果在创建表的时候，没有显式地定义主键（primary key）：

  * 如果有非空的唯一索引（unique not null），则该列为主键

  * 否则：自动创建一个6字节大小的指针

## 存储结构

> 所有数据都存放在一个空间中 ( 表空间 )：段 --> 区 --> 页 ( 块 )

### 表空间

* 默认一个公共表空间，所有的数据存于此，曰：ibdata1
* 若启用 innodb_file_per_table：则每张表的数据可以单独放到一个表空间内
  * 此时，每张表空间存放的只是数据、索引、插入缓存
  * 其他信息还是在共享表空间内

### 段

* 数据段、索引段、回滚段、......
* 表空间由分散的页和段组成：因为有些对象没有段

### 区

* 由 64 个连续的页组成，每个页 16 KB，每个区 1 MB
* 大多数的段每次最多可以申请 4 个区

### 页

* 是 InnoDB存储引擎最小的管理单位

### 行

* InnoDB 是面向行的
* 每个页最多存放 7992 行记录：16KB / 2

## 行记录格式

> Compact、Redundant

### Compact

* 高效存储数据：如果一个页中存储的数据越多，性能越好
* MySQL 5.0 时引入

### Redundant

* MySQL 5.0 之前引入

### 行溢出数据

* 某些数据可以不记录在数据页中，而是作为行溢出数据
* BLOB、LOB、VARCHAR 等可能存储大对象类型的类型可以将数据放在溢出页面

### ......

## 页结构

### File header

> 该页的校验和、表空间中该页的偏移量、当前页的上一页和下一页、页的类型、表空间ID

### Page header

* 页目录中的槽数
* 堆中第一个记录的指针
* 堆中的记录数
* 指向空闲列表的首指针
* 已删除记录的字节数
* 最后插入记录的位置
* 最后插入的方向
* 一个方向连续插入的数量
* 该页中记录的数量
* 当前页的最大事务ID
* 当前页所在的索引树的位置
* 当前页所属的索引ID
* ......

### Infimum 和 Supremum 记录

> 每个数据页有两个虚拟的行记录，以限定记录的边界。在页创建时被建立，且不会被删除

* Infimum
  * 记录比该页中任何主键值都小的值
* Supremum
  * 记录比任何可能的值都大的值

### User records

> 实际存储的行记录内容

### Free Space

> 空闲空间，链表结构。当一条记录被删除时，该空间会被加入空闲空间中

### Page Directory

* 页目录存放了记录的相对位置，而非偏移量。这些记录指针又称为槽或者目录槽
* 槽是稀疏目录，一个槽可能属于多个记录。最少4条，最多8条
* 槽中记录按照键的顺序存放

## 约束

### 数据完整性

* 实体完整性

> 保证表中有一个主键：primary key 或者 unique key

* 域完整性

> 保证数据的值满足特定的条件：合适的数据类型、外键约束、DEFAULT 约束

* 参照完整性

> 保证两个表之间的关系，外键实现

### InnoDB 的 4 种约束

* Primary Key
* Unique Key
* Foreign Key
* Default
* Not Null

### 约束和索引的区别

* 约束是逻辑概念，以保证数据完整性
* 索引是一个数据结构，有逻辑上的概念，也通过物理方式进行实际的存储

### 触发器

* 在 INSERT、DELETE、UPDATE 命令之前或者之后进行自动调用 SQL 命令或者存储过程，实现完整性约束

### 外键

> 尽量在代码层实现

## 视图

> 虚表，没有物理表现形式

### 作用

* 被用作为一个抽象装置，起到安全层的作用
* 也可以通过视图的定义更新基本表

### 物化视图

* MySQL 本身不支持物化视图，但是通过某些机制实现物化视图的功能

## 分区表

### 概述

* 将表或者索引物分解为更小的部分
* 仅支持水平分区：同一张表中的不同行记录被分到不同的物理文件中
* 局部分区索引：一个分区中既存放了数据，也存放了索引
* 如果表中存在主键或者唯一索引时，分区列必须是唯一索引的一部分

### Range 分区

* 创建表时，可以通过建表语句创建 Range 分区。该分区方式指定了每个分区应该存放的数据范围
* 指定的分区数量有多少，就会有多少物理文件存储对应范围的数据，而不是一个单独的表空间文件
* 需要插入的数据，依据分区列进行对应的插入
* 当插入了一个未在分区中定义的数据时，MySQL 会抛出异常
* 该分区主要用于日期列的分区，以便于能根据特定的分区查询、删除、修改某段日期内的数据

### List 分区

* 类似于 Range 分区，只是分区列的值是离散的，而非连续的
* 各分区内的数据是指定的一个个具体值（1，4，6，8），而不是值范围（1 ~ 10）

### Hash 分区

* 将需要插入的数据随机地均匀分布到定义好的各个分区中，以保证各分区内的数据数量大致上是一样的
* 在创建表时需要自定义 hash 函数，确定 hash 规则

### Key 分区

* 使用 MySQL 内置函数定义分区规则，内置的 hash 函数

### Columns 分区

* 以上 4 种方式的分区条件必须是整数，否则的话，应该通过某些函数转化为整数
* 支持的分区条件类型
  * 所有的整型：FLOAT 和 DOUBLE 不支持
  * 日期：DATE 和 DATETIME，其余不支持
  * 字符串：BLOB 和 TEXT 不支持
* 日期类型可以直接使用 COLUMNS (如，less than ‘2010-08-08’)

### 子分区

* 在分区的基础上再进行分区，或曰：复合分区
* 在 Range、List 分区上再进行 hash 或者 Key 分区

### 分区中的 NULL 值

> Null 值作为分区列时

* Range 分区，将插入的 null 值放在最左边的分区
* List 分区，需要显示指定哪个分区中存放 NULL 值
* HASH 和 KEY 分区，分区函数将含有 NULL 值的记录返回为 0

### 分区和性能

* OLTP：在线事务处理
  * 场景：用户应用
  * 需要小心分区，分区性能未必好
* OLAP：在线分析处理
  * 场景：后台管理系统
  * 如果数据庞大，大部分情况需要分区，性能提升显著

# 索引和算法

## 概述

> InnoDB 两种常见的索引：B+树索引、哈希索引

* B+树索引
  * 即为传统意义上的索引，最为经常使用，也最为有效
  * 类似于二叉树，通过键值对快速找到数据
  * B 不是二叉 binary，而是平衡 balance
  * 由平衡二叉树演化而来，但不是二叉树
* 注意：通过该类索引，不能直接找到给定键值对的具体行，而是被查找数据行所在的页，然后把页读入内存，再在内存中进行查找，最终找到具体数据所在的行

## 平衡二叉树

### 二叉树

* 左子树的键小于根的键，根的键小于右子树：left < root < right
* 可以通过中序遍历，迅速查找出数据

### B+树

* 所有的记录节点都是按照键的大小顺序放在同一层的叶子节点上，各叶子节点通过指针连接
* 其余，暂略

### B+树索引

* 在数据库中的高度一般都在 2 ~ 3 层。因此，查找到一条记录需要 2 ~ 3 次的 IO
* 聚集索引
  * 按照每张表的主键构造一颗 B+ 树，并且叶节点存放整张表的行记录
  * 每张表只能有一个聚集索引
* 辅助索引

### B+树索引的使用

- 当访问表中很少一部分数据时，考虑使用 B+ 树索引，高选择性

  - 如：id，username，不会有重复出现，选择性高
- 但是，当使用高选择性的字段，选择出的行数据过多，占据了表中的大部分数据时，不使用

  - 如：integer 类型的 id 范围查询
- 顺序读

  - 磁盘：顺序读取磁盘上的块，性能高于磁盘的随机读
  - 数据库：根据索引的叶节点数据就能顺序读取所需的行数据
  - 逻辑上是顺序读取，在物理磁盘上，仍有可能是随机读
  - 物理磁盘数据存储相对而言比较顺序，因为是根据区来管理的，而区是 64 个连续的页
- 随机读

  - 磁盘：访问的块是不连续的，需要磁头不断移动。传统机械磁盘的瓶颈
  - 数据库：需要根据辅助索引叶节点中的主键查找实际行数据
- 预读取

  - 通过一次 IO 请求将多个页数据预读到缓冲池中，并且估计预读取的多个页数据会立刻被访问
  - 传统的 IO 请求每次仅读取一个页
  - 提高了读取的性能
  - 2 个预读取方式
    - 随机预读取
      - 当一个区 (64个页) 中有13个页在缓冲区中，并在LRU列表的前端，则 InnoDB 将这个区中剩余的页预读取到缓冲区
    - 线性预读取
      - 如果一个区的24个页都被顺序访问了，则 InnoDB 会读取下一个区的所有项
- 辅助索引的优化使用
  - 辅助索引的叶节点包含主键，但不包含完整的行信息
  - InnoDB 先从辅助索引判断是否能得到所需要的数据
- 联合索引
  - 对表上的多个列添加索引

### 哈希算法

* 哈希表（散列表），改进于直接寻址表（数组）
* 数组和链表
* 碰撞：哈希函数结果映射到同一个槽
* 解决碰撞：链地址法，把散列到同一个槽的所有元素放在一个链表中

# 锁

> 管理对共享资源的并发访问，在行级别上对表加锁

## InnoDB 中的锁

### 锁类型

* 共享锁（S Lock）
  * 允许事务读一行数据
* 排他锁（X Lock）
  * 允许事务删除或者更新一行数据

> 当一个事务已经获取到了行 r 的共享锁，另外事务可以立即获取到行 r 的共享锁：锁兼容
>
> 另外的事务想获取行 r 的排它锁，必须要等到事务释放行 r 上的共享锁

* 意向锁

  > 额外的锁方式。支持在不同粒度进行加锁操作。
  >
  > 不会阻塞除全表意外的任何请求：因为 InnoDB 支持的是行级别的锁

  * 意向共享锁
    * 事务想要获得一个表中某几行的共享锁
  * 意向排它锁
    * 事务想要获得一个表中的几行排它锁

### 一致性的非锁定读操作