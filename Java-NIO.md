# 简介

## I/O 概念

### 缓存区操作

* 是 I/O 的基础。I/O 即将数据移入或者移出缓冲区
* 进程执行 I/O 操作，即向操作系统发出请求。让其把缓冲区里的数据排干(写)，或者用数据把缓冲区填满(读)

![image](https://github.com/rayest/Document/raw/master/images/I:O缓存区操作.png)

* 读操作是进程通过向系统发出读请求，使用 `read()`系统调用。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器将数据从磁盘写入内核缓冲区，内核再把数据从**内核空间**的临时缓冲区拷贝到**用户空间**的缓冲区

* 用户空间：常规进程所在的区域。JVM 即为常规进程，常驻于用户空间，不能直接访问硬件设备

* 内核空间：操作系统所在区。能与设备控制器通讯，控制着用户区域进程的状态

* 而所有 I/O 都直接或者间接通过内核空间

* 注意：

  * 当进程请求 I/O 操作的时候，执行一个系统调用将控制权交给内核。内核采取相应的方式找到该进程需要的数据，并把数据输送到用户空间指定的缓冲区
  * 内核会对磁盘读取的数据进行高速缓存或者预读取，如果缓冲区已经存在进程需要的数据，则不需再从磁盘读取
  * 用户空间和内核空间：硬件不能直接访问用户空间；用户空间可能请求任意大小的数据块，而磁盘是基于块存储的，操作的是固定大小的数据块，内核负责数据的分解与再组合

* 发散/汇聚

  * 进程只需一个系统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或者排干多个缓冲区，读的时候就把数据**发散**到多个用户缓冲区，写的时候再从多个缓冲区**汇聚**起来

  ![image](https://github.com/rayest/Document/raw/master/images/三个缓冲区的发散读操作.png)

### 虚拟内存

* 所有的现代操作系统都是用虚拟内存。即用虚拟地址代替物理内存地址`硬件RAM`
  * 一个以上的虚拟地址可以指向同一个物理内存地址
  * 虚拟内存空间可大于实际可用的硬件的内存
* 使用虚拟内存，可以把内核空间地址与用户空间的虚拟地址映射到同一个物理地址。这样，DMA 硬件(只能访问物理内存地址)就可以填充对**内核**与**用户空间**进程**同时可见**的**缓冲区**

![image](https://github.com/rayest/Document/raw/master/images/内存空间多重映射.png)

* 节省了内核空间与用户空间的往来拷贝。前提是，内核与用户缓冲区必须使用相同的**页对齐**，缓冲区的大小还必须是**磁盘控制器块**大小(通常为 512 字节磁盘扇区)的倍数。操作系统把**内存地址空间**划分为**页**，即固定大小的字节组。内存页的大小总是磁盘块大小的倍数，通常为 2 次幂(这样可简化寻址操作)。典型的内存页为 1,024、2,048 和 4,096 字节。虚拟和物理内存**页的大小**总是相同的。下图显示了来自多个虚拟地址的虚拟内存页是如何映射到物理内存的

![image](https://github.com/rayest/Document/raw/master/images/内存页.png)

### 内存页面调度

* 为实现虚拟内存寻址空间大于物理内存，就必须进行虚拟内存分页(或称为**交换**，真正的交换是在进程层面完成，而非页层面)
* 虚拟内存空间的页面能够继续存在于外部磁盘存储，就为物理内存中的其他虚拟页面腾出了空间
* 物理内存充当了分页区的高速缓存；而所谓分页区，即从物理内存置换出来，转而存储于磁盘上的内存页面

![image](https://github.com/rayest/Document/raw/master/images/用于分区页高速缓存的物理内存.png)

* 以上。显示了分属于四个进程的虚拟页面，其中每个进程都有属于自己的虚拟内存空间。进程 A 有五个页面，其中两个装入内存，其余存储于磁盘
* 把内存页大小设定为磁盘块大小的倍数，这样内核就可直接向磁盘控制硬件发布命令，把内存页写入磁盘，在需要时再重新装入。结果是，所有磁盘 I/O 都在页层面完成
* 计算机CPU 包含一个称为内存管理单元(MMU)的子系统，逻辑上位于 CPU 与物理内存之间。该设备包含虚拟地址向物理内存地址转换时所需映射信息

