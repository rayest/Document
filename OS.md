# 概述

## 基本特性

### 并发性

* 并发：多个事件在同一时间间隔内发生
  * 多道程序环境下，一段时间内宏观上多个程序同时运行
* 并行：多个事件在同一时刻发生
  * 单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行
* 进程：为了使多个程序能并发执行
  * 在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。
  * 多个进程之间可以并发执行和交换信息。一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等
* 线程：进程拥有自己的资源，调度付出的开销较大
  * 一个进程中包含若干个线程，可以利用进程所拥有的资源
  * 在引入线程的 OS 中，把进程作为分配资源的基本单位
  * 把线程作为独立运行和独立调度的基本单位
  * 由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小

### 共享性

* 系统中的资源可供内存中多个并发执行的进程(线程)共同使用

### 虚拟技术

* 把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的，即实际存在的，而后者是虚的，仅是用户感觉上的东西
* 时分复用技术
  * 分时使用方式：虚拟处理机技术（为每道程序建立一个进程，让多道程序并发地执行，以此来分时使用一台处理机）、虚拟设备技术（一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备）
* 空分复用技术
  * 虚拟磁盘技术、虚拟存储器技术

### 异步性

## 主要功能

### 管理处理机

* 创建和撤销进程或者线程、协调各个进程或线程、实现进程或线程通信、为处理机分配进程或线程

### 管理存储器

* 内存分配与回收：为每道程序分配内存空间，并回收不再需要的内存
* 内存保护：确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰
* 地址映射、内存扩充等

### 管理设备

* 缓冲管理：在内存中设置了缓冲区，改善IO性能
* 设备分配：根据 IO 请求、系统资源等为之分配设备
* 设备处理：......
* 虚拟设备

### 管理文件

* 对用户文件和系统文件进行管理：对文件存储空间、目录、读写、共享与保护的管理

# 进程管理

## 基本概念

### 结构

* PCB：进程控制块。程序段、相关的数据段、PCB 构成了进程实体

### 基本的 3 种状态

* 就绪：当进程分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。多个就绪的进程被排成一个就绪队列
* 执行：进程已获得 CPU，其程序正在执行
* 阻塞：由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态。多个阻塞的进程被排成一个阻塞队列

### 挂起状态

* 终端用户的请求、父进程请求、负荷调节的需要、操作系统的需要

### 创建状态和终止状态

* 创建状态
  * 创建：为新进程创建 PCB，并填写必要的管理信息。将把其转入就绪状态并放到就绪队列中
  * 创建时主存资源尚未分配，创建工作还未完成，即为创建状态
  * 处于创建状态的进程，获得了必需的资源，以及对其PCB初始化工作完成后，转入就绪状态
* 终止状态
  * 首先等待操作系统进行善后处理，然后将其 PCB 清零，并将 PCB 空间返还系统
  * 到了自然结束点或者出现了无法克服的错误，而被终结
  * 进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。

### PCB 进程控制块

* 作用
  * 是操作系统中进程的记录型数据结构
  * 记录了用于描述进程的当前情况以及控制进程运行的全部信息。
  * 使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。
  * OS 是根据 PCB 来对并发执行的进程进行控制和管理的
* PCB 中的信息
  * 进程标识符：唯一标识一个进程
  * 处理机状态信息：处理机的各种寄存器中的内容
  * 进程调度信息：进程优先级、进程状态、事件（阻塞原因等）、其他（已执行时间、等待CPU时间等）
  * 进程控制信息：程序和数据的地址、进程同步和通信机制（消息队列和信号量）、资源清单、链接指针（该进程在队列中指向下一个进程的PCB的首地址）
  * PCB 的组织方式：一个操作系统中多个 PCB 可以通过链接方式和索引方式

## 进程控制

* 创建进程、终止进程、进程状态转换。由操作系统的内核中的原语实现
* 原语：若干条指令组成，以完成一定功能。常驻内存。实现进程的通信和控制

### 进程创建

> 当操作系统发现出现需要创建进程事件时，会调用进程创建原语创建进程

* 申请空白 PCB。为新进程申请获得一个唯一的标识符，并从 PCB 集合中索取一个空白 PCB
* 为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间
* 初始化进程控制块。
  * 初始化标识信息：将分配的唯一标识符和父进程的标识符填入 PCB 中
  * 初始化处理机状态信息：使程序计数器指向程序的入口地址，使栈指针指向栈顶
  * 初始化处理机控制信息：将进程的状态设置为就绪状态或者静止就绪状态。且一般会将其优先级设置为最低
  * 将新进程插入就绪队列

### 进程的终止

* 正常结束：自然完成自己的使命。在程序的最后安排一条 Holt 指令或者终止系统的调用。当运行到此处时，产生中断，通知 OS 本进程已经完成

* 异常结束：遇到错误或故障而被迫终止

* 外界干预：进程应外界的请求而终止运行

* 终止过程：

  > 若系统发生了终止的事件， OS 便调用进程终止原语，逐步终止进程运行

  * 根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从中读取出该进程的状态
  * 若进程处于运行状态，则立即终止，并设置调度标识为真，以指示该进程被终止之后应重新进行调度
  * 若进程还有子进程，将其所有子进程也都终止
  * 将被终止的进程所拥有的所有资源，归还给父进程或者系统
  * 将被终止的进程 ( PCB ) 从队列中移出，等待其他程序来搜集信息

### 进程的阻塞和唤醒

* 阻塞过程
  * 出现阻塞事件时，进程调用阻塞原语阻塞自己，将进程块中的执行状态改为阻塞状态，并将 PCB 插入到阻塞队列
* 唤醒过程
  * 当被阻塞进程所期待的事件出现时，由其他相关进程调用唤醒原语，将阻塞的进程唤醒
  * 把被阻塞的进程从等待该事件的阻塞队列中移出，将其 PCB 阻塞状态改为就绪，并将 PCB 插入到就绪队列中
  * 就绪队列中的进程等待新的调度
* 当进程执行阻塞原语后，必须通过唤醒原语进行唤醒，才能继续执行，否则永远在阻塞队列中而无法执行

### 进程的挂起与激活

* 挂起：发生挂起进程的事件时，系统使用挂起原语将制定进程挂起
  * 检查进程状态，若处于活动就绪状态，则改为静止就绪；若为活动阻塞状态，则改为静止阻塞
  * 将进程的 PCB 复制到指定的内存区域
  * 若被挂起的进程正在执行，则转向调度程序重新调度
* 激活：发生激活进程的事件时，若进程驻留在外存而内存空降足够，将进程换入内存
  * 激活原语先将进程从外存调入内存，检查进程现行的状态
  * 若为静止就绪，则改为活动就绪
  * 若为静止阻塞，则改为活动阻塞

## 进程同步

> 对多个进程在执行次序上进行协调，使并发的进程能有效的共享资源和相互合作

### 基本概念

* 间接制约（共享资源时）和直接制约（相互合作时）
* 临界资源和临界区：对临界资源必须互斥访问，访问临界资源的那段代码为临界区
* 进入区：访问临界资源前，用于检查欲访问的临界资源是否可以访问
* 退出区：用于将临界区被访问的标志恢复为未被访问
* 实现同步的规则：
  * 空闲让进、忙则等待、有限等待、让权等待

## 进程通信

> 进程间信息交换：状态或者字节数据

### 类型

* 共享存储器系统：相互通信的进程共享某些数据结构或存储区，他们通过这些空间进行通信
  * 基于共享数据结构的通信：相互通信的诸进程公用某些数据结构，实现信息交换
  * 基于共享存储区的通信：对共享存储区中的数据读和写实现通信
* 消息传递系统：最为广泛
  * 进程间数据交换是以格式化的消息（message，或曰：报文）为单位
  * 直接通信
    * OS 提供发送命令，直接把消息发送给目标进程：send 和 receive: message 
  * 间接通信
    * 进程间需要共享数据结构实体（信箱），用于暂存进程消息。发送进程将消息发送至此，接收进程从此取出发给自己的消息
  * 必须先在两者之间建立一条通信链路，在链路使用完以后，显式地拆除链路
  * 消息格式：消息头和消息正文

* 管道通信
  * 用于连接读进程和写进程，是实现进程间通信的一个共享文件：pipe 文件
  * 以字符流的形式将数据送入管道或者从管道接收数据流
  * 源于 UNIX 系统

## 线程

### 基本概念

* 减少程序在并发时付出的开销
* 调度：线程作为调度和分派的基本单位，进程作为资源拥有的基本单位。线程不拥有资源
* 并发：一个进程内多个线程并发
* 系统开销：线程切换仅需要保存和设置少量寄存器内容，不涉及存储器管理方面的内容。进程内的多个线程有相同的地址空间，容易实现同步和通信。线程的切换、同步和通信都不需要系统内核的干预
* 轻型实体：只有一小部分能保证其正常独立运行的资源：线程控制块等

### 线程间同步和通信

* 互斥锁（mutex）：实现线程间对资源互斥访问。操作互斥锁的时间和空间开销比较低。有开锁（unlock）和关锁（lock）两种状态。对共享资源访问时，判断互斥锁的状态，以决定是否执行开锁命令，在访问时，需要执行关锁命令，访问结束需要执行开锁命令，并将阻塞该互斥锁上的其他线程唤醒
* 条件变量：与互斥锁一起使用，随互斥锁的创建而产生。用于线程长时间的等待，直至资源可用

### 线程的实现方式

* 通常进程的创建、撤销、完成IO操作都是利用系统调用而进入内核，再由系统内核中的相应处理程序处理，进程的切换也是在内核的支持下实现的。因此进程和内核紧密相连
* 内核支持线程：线程的创建、撤销、切换也是依靠内核，在内核空间实现。内核空间设置了线程控制块，以使内核感知线程的存在
* 内核可以同时调度和处理同一进程中的多个线程
* 用户级线程：仅存在于用户空间中，与内核无关，节省了内核资源

### 线程的实现

* 内核支持的线程的实现
  * 在创建一个进程时，为其分配一个任务数据区，其中包括若干线程控制块TCB空间
  * 在每一个 TCB 空间中可保存线程标识符、优先级、线程运行的 CPU 状态
  * 线程的撤销过程和进程的相似
* 用户级线程的实现
  * 在用户空间，而非内核。运行在一个中间系统上
  * 运行时系统：用于管理和控制线程的函数集合，包括用于创建和撤销线程的函数、线程同步和通信函数。
  * 内核控制线程：又曰为轻型进程 LWP。每一个进程可以拥有多个 LWP，每个 LWP 都拥有自己的数据结构 TCB。可以通过系统调用以获得内核提供的服务。为控制 LWP 的数量在合理的范围内，又设置了缓冲池，称为线程池

# 处理机调度和死锁

## 处理机调度的层次

### 高级调度

* 把外存上处于后备队列中的作业调入内存，调度对象是作业（每隔几分钟进行一次作业调度）
* 作业和作业步：如，编译 --> 装配 --> 运行
* 作业控制块（JCB）：是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需要的全部信息：标识符等信息和资源
* 作业进入系统时，系统会为其建立JCB，并插入到后备队列中，根据算法进行调度，被调度到的作业会进入内存
* 作业撤销时，回收相关资源、撤销JCB

### 低级调度

* 进程调度、短程调度。调度对象是进程（每个10~100ms进行一次调度）
* 保存处理机的现场信息：程序计数器、多个通用寄存器中的内存
* 根据算法选取进程：优先级、轮转法、从就绪队列中选取进程，并为之分配处理机
* 将处理机分配给进程：由分配程序将处理机分配给进程
* 排队器：将所有的就绪进程按一定方式排成一列或多列
* 分派器：将就绪进程从队列中选出，并进行上下文切换，并分配处理机
* 非抢占式调度：在处理机被分配给线程后，会一直运行直到进程完成，自动释放处理机，不会因为其他原因而被抢占处理机
* 抢占式调度：允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机重新分配给另一个进程。防止处理机被一个进程长期占有，实现进程公平。但是调度开销较大。
  * 时间片原则：各个进程按时间片轮流运行，用完时间片时，停止运行，重新调度
  * 优先权原则：对某些较为重要的、紧急的作业赋予较高的优先级，该类进程可以抢占当前进程的处理机
  * 短作业优先：允许具有明显短时间的进程抢占较长作业的处理机

## 调度队列模型和准则

###调度队列模型 

* 仅有进程调度：分时系统中，在FIFO队列中，按时间片轮转运行和调度
* 有进程调度和作业调度
  * 先按作业调度调入一批作业到内存中，为其建立进程，送入就绪队列中
  * 再按进程调度选取一个进程，为之分配处理机

### 准则

* 面向用户：周转时间短、响应时间快、优先权
* 面向系统：吞吐量高、处理机利用率好、资源得到平衡

## 调度算法

### 先来先服务和短作业优先调度

* 先到先得的进程（利于长时间作业）、运行时间可能比较短的短作业（利于短时间作业）

### 高优先权调度

* 非抢占式和抢占式（比较优先权比重）
* 高响应比
* 等待时间和服务时间之和为响应时间，相当于优先权。越短优先权越高
* 同时照顾了短作业和长作业，较为公平

### 时间片轮转调度

* 基本原理：将就绪进程按FCFS原则排成队列，调度时将CPU分配给队首进程，命令其执行一个时间片(几十毫秒到几百毫秒)，时间片用完时，由计时器发出时钟中断请求，通过该信号停止执行进程，并将该进程送往队尾，再讲=将CPU分配给新的队首进程
* 时间片大小：略大于一次典型的交互所需要的时间，使得大多数的进程都可以在一个时间片内执行完成
* 多级反馈队列调度算法：多个队列，每个队列时间片不同，按队列以此执行。当前一列为空时，进行下一列调度

## 实时调度

### 基本条件

* 必要的信息：就绪时间、开始截止和完成截止时间、处理时间、资源要求、优先级
* 采用抢占调度机制
* 快速切换机制：对外部中断的快速响应、快速的任务分派能力
* 抢占式和非抢占式

## 死锁的原因

* 竞争资源、进程间推进顺序非法
* 预防死锁、避免死锁、检测死锁、解除死锁：剥夺资源撤销进程