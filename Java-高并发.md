# 并行的世界

## 基本概念

* 同步
  * 同步方法调用一旦开始，调用者必须等到方法调用返回结束后，才能继续后续的行为
* 异步
  * 异步方法在另一个线程中执行，不会阻碍调用者的工作
  * 若异步调用有返回结果，则当异步调用真实完成时。则会通知调用者
* 并发
  * 多个任务交替执行，整个过程是交替执行的，系统会不停地在多个任务之间切换
* 并行
  * 同时执行，仅可能出现在拥有多个CPU的系统中
  * 一个CPU一次仅能执行一条指令
* 临界区
  * 表示公共资源或者共享数据，可以被多个线程使用，每一次只能有一个线程使用，其他线程需等待该资源的释放
* 阻塞
  * 线程等待资源释放而暂停工作
* 非阻塞
  * 线程正常执行，没有受到其他线程的影响而无法工作
* 死锁
  * 线程之间需要彼此占用的资源，导致彼此不能释放资源
* 饥饿
  * 线程无法获得需要的资源，导致一直无法继续执行
* 活锁
  * 线程之间过度谦让，主动将资源释放给别的线程，导致资源在线程之间来回跳动，而无一个线程能拿到所有的资源以正常执行

## 并发级别

* 临界区的存在，使得必须要控制多线程之间的并发，根据并发的策略，把并发的级别分为了阻塞、无饥饿、无障碍、无锁、无等待

# 并行程序基础

## 线程的基本操作

### 新建线程

> ```java
> public class ThreadDemo1 implements Runnable{
>     
>     private static Logger logger = LoggerFactory.getLogger(ThreadDemo1.class);
> 
>     @Override
>     public void run() {
>         System.out.println("实现 Runnable 接口，处理业务逻辑");
>     }
> 
>     public static void main(String[] args) {
>         logger.info("新建线程并启动");
>         Thread thread = new Thread(new ThreadDemo1());
>         thread.start();
>     }
> }
> ```

* `new Thread()` 并实现 `Runnable `接口

### 终止线程

* `new Thread().stop()` 用于暴力终止线程，已被摒弃
* 可能会在多线程数据写入时，导致数据写入不一致
* `stop`会直接终止线程，并且会立即释放该线程所持有的锁，该锁用于维持对象的一致性。当数据写入一部分时，被直接终止，写对象遭到破坏，会被另外的线程读到该不一致的数据
* 可以自行定义线程终止的条件，当满足该条件时，就退出线程

### 线程中断

* 不会使线程立即退出，而是会给该线程发送通知，该线程收到该通知后，会根据具体情况自行处理

* 线程中断涉及到的三个方法

* ```java
  public void Thread.interrupt() // 中断线程，设置中断标志位
  public boolean Thread.isInterrupted() // 判断线程是否被中断，检查中断标志位
  public static boolean Thread.interrupted() // 是否被中断，并清除当前中断状态，清除中断标志位
  ```

* 三个方法都涉及到`中断标志位`

  * 如果要通过该方法退出线程，需要先中断线程，并在判断其中断状态后，执行退出操作

### Sleep 函数

* 使当前线程休眠若干时间，当休眠中的线程被中断时，会抛出中断异常`InterruptedException`

### Wait 函数和Notify 函数

* `wait()`和`notify()`是 Object 类的内部方法，可供任何对象调用。实例对象调用该方法后，当前线程就会停止继续执行，而在该对象上等待，直到其他线程调用 `notify()`方法为止，线程才继续执行
* 线程调用`wait()`方法后会进入对象的等待队列，该队列中可能有多个线程同时等地一个对象
* 线程调用`notify()`方法后，对象会在等待队列中随机选择一个线程，并将其唤醒
* `notifyAll()`会唤醒等待队列中的所有线程
* `wait()`的调用必须在`synchronized`语句中，`wait()`和`notify()`都需要首先获得目标对象的一个监视器
* `wait()`执行后会释放这个监视器
* `wait()`方法也可以让线程等待若干时间，且该方法会释放目标对象的锁，而`sleep`方法不会释放任何资源

### Suspend 和 resume

* 挂起和继续执行。被 Thread 废弃的方法
* 一对相反的操作，被挂起的线程只有在等到resume后才会继续执行
* `suspend`会将线程挂起，但是并不释放任何锁资源，导致该锁无法被任何线程使用

### Join 和 yield

* `join() 和 join(long millis)`：一个线程的输入依赖于另一个线程的输出，需要等到依赖线程的执行完毕，才继续执行
* 一个线程加入另一个线程，如主线程中加入了一个新线程
* `join` 的本质是让调用线程`wait`在当前线程对象实例上
* `yield()`方法被执行后，会使当前线程让出 CPU，之后还会进行 CPU 的争夺
* 如果一个线程不太重要或者优先级比较低且占用较多的 CPU，可以尝试 `yield`

## Volatile 与 Java 内存模型（JMM）

* volatile 等关键字用于告诉虚拟机，该处比较特殊，需要注意
* `易变的、不稳的`，用于标记某些字段，以使 JVM 采取特殊手段，保证该字段的可见性和有序性
* 保证了操作的原子性，但不能代替锁

### 内存模型

* 计算机执行时，每条指令都是在 CPU 中执行的，就会涉及到数据读取和写入，为缓解 CPU 指令执行速度和从内存中操作数据的差异性，在 CPU 中引入了高速缓存
* 程序运行过程中，数据的操作都是在高速缓存中进行的，在运算结束后。再将高速缓存中的数据刷新到主存中
* 单线程运行没有问题，但是多线程运行时就会出现问题
* 在多核 CPU 中，每条线程可能运行于不同的 CPU，因此每条线程拥有自己的高速缓存，这将导致数据存在缓存不一致的问题。即一个变量在多个 CPU 中都存在缓存，而这些缓存的结果可能不一样
* 2 种解决方法，都是硬件层的方式
  * 在总线加 LOCK# 锁
    * 阻塞其他 CPU 对其他部件的访问，使只能有一个 CPU 能使用这个变量的内存。即在等待含有共享变量的代码全部执行完毕，其他 CPU 才能从变量所在的内存读取变量
    * 在锁住总线期间，其他 CPU 无法访问内存，效率低
  * 通过缓存一致性协议
    * 保证每个缓存中使用的共享变量的副本是一致的
    * 当写数据时，若操作的变量是共享变量，在其他 CPU 中也存在该变量的副本，会发出信号通知其他的 CPU 将该变量的缓存设置为无效状态，当该 CPU 需要读取这个变量时，发现自己缓存中的缓存变量是无效的，就会从内存中重新获取
* 并发编程常见的三个问题是：原子性问题、可见性问题、有序性问题（指令重排）
* 指令重排
  * 如在某些方法中有多条语句，代码按一定顺序编写好之后，JVM实际执行时的顺序是不一定的，即发生了指令重排
  * 指令重排是处理器为了提高程序运行效率，自身对输入代码进行优化的，它不保证程序中各个语句的执行先后顺序和代码中的一致，但会保证最终执行的结果是一致的
  * 不会影响到单线程的执行结果，但是会影响到多线程的执行结果
* Java 内存模型
  * 屏蔽了各个硬件平台和操作系统的内存访问差异，实现在各个平台下一致的内存访问结果
  * 也有缓存一致性问题和指令重排问题
  * 规定所有的变量都存在主存（物理内存）中，每个线程有自己的工作内存即类似于高速缓存
  * 线程对变量的所有操作都必须在工作内存中进行，而非在主存中进行，线程之间不能互相访问工作内存
  * `y=x`语句其实不是原子性操作，包含两个操作，一个是读取 `x`操作，一个是将`x`写入内存操作
  * JMM 只保证了基本读取和赋值是原子性操作，但是更大范围的原子性操作需要 synchronized 或者 Lock 来实现。两种方式能够保证任意时刻只有一个线程可以操作该端代码，不存在原子性问题
  * volatile 关键字保证可见性
    * 保证被该关键词修饰的共享变量在被修改后立即更新到主存，当有其他线程需要时。从内存重新读取
    * synchronized 和 Lock 也可以保证可见性，在释放锁之前会将对变量的修改刷新到主存中
  * volatile 和 synchronized、lock 可以保证变量的有序性
* volatile
  * 保证了不同线程对该变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
  * 禁止进行指令重排序，在一定程度上保证有序性
  * 没办法保证对变量的操作的原子性
  * 自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行

## 线程组

* 当线程数量很多时，如几十个上百个，可以使用线程组，将相同功能的线程放在一个线程组里

## 守护线程 daemon

* 是系统的守护者，完成一些系统性服务，如垃圾回收线程和JIT线程。与之对应的是用户线程
* 用户线程完成一些业务工作，当用户线程全部结束，守护线程守护的对象已不存在，整个应用程序应该退出
* 只有守护线程时，JVM会自动退出