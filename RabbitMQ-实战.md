# 天降奇兵

* 消息队列使用消息将应用程序连接起来，RabbitMQ 作为消息代理服务器在程序之间路由，似邮局
* AMQP：高级消息队列协议

## 运行

* ```bash
  $ cd /usr/local/Cellar/rabbitmq/3.7.4/sbin
  $ rabbitmq-server
  $ rabbitmqctl status
  ```

* 用户和密码：admin、admin（代码里会用到）

# 理解消息通信

* 解耦、肖峰、异步
* AMQP 为离线消费存储消息，这些消息没有固定的结构，解耦通信，隐去了消息的发送方和接收方
* 可以一对多或者一对一的路由进行程序间的通信
* 消息分为有效负荷和标签，rabbit 根据标签决定将消息发送给接收方。发后即忘
* 通信之前先建立信道 channel。在应用程序和rabbit之间创建 tcp 连接，然后创建一条信道
* AMQP 的命令都是在信道中发送出去的，可以在一个TCP连接上创建成千上万的信道，而不会影响操作系统

## 队列

* AMQP 消息路由有三个部分：交换器、队列、绑定
* 生产者将消息发送到交换器上并被消费者接收，绑定决定了消息如何从路由器路由到特定的队列
* 当有至少一个消费者订阅了队列的话，消息会立即发送给这些订阅的消费者
* 无人订阅时，消息会在队列中等待，直到有消费者订阅时，立即发送之
* 多个消费者时，队列将消息以循环的方式依次将消息发送给消费者，每个消息只会发送给其中的一个消费者，消费者需要向 rabbitMQ 额外的确认
* 创建队列
  * 若消费者在同一个信道上订阅了另一个队列，就无法再申明新队列了，必须先取消订阅，将信道置为传输模式
  * 创建和订阅时都需指定队列的名称，创建绑定时也需要指定队列的名称，如不指定则会被随机分配一个

## 交换器和绑定

* 消息到达时，需要将消息发送给交换器来完成，然后根据规则决定消息会投递到哪个队列，这些规则称为路由键
* 队列通过**路由键**绑定到交换器，且交换器有4种类型，分别有不同的路由算法
* direct
  * 如果**路由键**匹配的话，就将消息投递到对应的队列
* fanout
  * 将收到的消息广播到绑定的队列上。即当一条消息到达fanout交换器时，会把消息投递到所有附加在该交换器的队列上
  * 亦即若某一个交换器附加了若干个队列 ( 这些队列用以处理不同的业务 )，当一条消息先到达交换器时，交换器会将该条消息投递给上述的几个队列中
  * fanout 交换器不处理路由键
* topic
  * 可以使得来自不同源头的消息能够达到同一个队列，通过路由键实现
* headers
  * 几乎不会用到。略去

## 持久化策略

* 默认情况下，重启 RabbitMQ 后，Rabbit 创建的队列和交换器都会被自动删除
* 原因在于每个队列和交换器的 durable 属性默认为 false
* 持久化的操作
  * 把它的投递模式选项设置为 2，即持久
  * 发送到持久化的交换器
  * 达到持久化的队列

# 实战

## 1. 如何确保消息正确地发送至RabbitMQ？

* RabbitMQ 使用发送方确认模式，确保消息正确地发送到RabbitMQ。
* **发送方确认**模式：将**信道**设置成**confirm**模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。

## 2. 如何确保消息接收方消费了消息？

* **接收方消息确认**机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。
* 下面罗列几种特殊情况：
* 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
* 如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。

## 3. 如何避免消息重复投递或重复消费？

* 在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。

## 4. 消息基于什么传输？

由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。 

## 5. 消息如何分发？

若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。

## 6. 消息怎么路由？

从概念上来说，消息路由必须有三部分：**交换器、路由、绑定**。生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。

1. 消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。
2. 通过队列路由键，可以把队列绑定到交换器上。
3. 消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。

常用的交换器主要分为一下三种：

- direct：如果路由键完全匹配，消息就被投递到相应的队列
- fanout：如果交换器收到消息，将会广播到所有绑定的队列上
- topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符，比如：“*” 匹配特定位置的任意文本， “.” 把路由键分为了几部分，“#” 匹配所有规则等。特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由"."隔开的一系列的标识符组成。

## 7. 如何确保消息不丢失？

消息持久化的前提是：将交换器/队列的durable属性设置为true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要重新创建交换器/队列（交换器/队列会自动创建）。

如果消息想要从Rabbit崩溃中恢复，那么消息必须：

- 在消息发布前，通过把它的 “投递模式” 选项设置为2（持久）来把消息标记成持久化
- 将消息发送到持久交换器
- 消息到达持久队列

RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应（如果消息路由到了非持久队列，它会自动从持久化日志中移除）。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列（以及绑定），并重播持久化日志文件中的消息到合适的队列或者交换器上。