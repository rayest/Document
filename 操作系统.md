# 概述

## 基本特性

### 并发性

* 并发：多个事件在同一时间间隔内发生
  * 多道程序环境下，一段时间内宏观上多个程序同时运行
* 并行：多个事件在同一时刻发生
  * 单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行
* 进程：为了使多个程序能并发执行
  * 在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。
  * 多个进程之间可以并发执行和交换信息。一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等
* 线程：进程拥有自己的资源，调度付出的开销较大
  * 一个进程中包含若干个线程，可以利用进程所拥有的资源
  * 在引入线程的 OS 中，把进程作为分配资源的基本单位
  * 把线程作为独立运行和独立调度的基本单位
  * 由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小

### 共享性

* 系统中的资源可供内存中多个并发执行的进程(线程)共同使用

### 虚拟技术

* 把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的，即实际存在的，而后者是虚的，仅是用户感觉上的东西
* 时分复用技术
  * 分时使用方式：虚拟处理机技术（为每道程序建立一个进程，让多道程序并发地执行，以此来分时使用一台处理机）、虚拟设备技术（一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备）
* 空分复用技术
  * 虚拟磁盘技术、虚拟存储器技术

### 异步性

## 主要功能

### 管理处理机

* 创建和撤销进程或者线程、协调各个进程或线程、实现进程或线程通信、为处理机分配进程或线程

### 管理存储器

* 内存分配与回收：为每道程序分配内存空间，并回收不再需要的内存
* 内存保护：确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰
* 地址映射、内存扩充等

### 管理设备

* 缓冲管理：在内存中设置了缓冲区，改善IO性能
* 设备分配：根据 IO 请求、系统资源等为之分配设备
* 设备处理：......
* 虚拟设备

### 管理文件

* 对用户文件和系统文件进行管理：对文件存储空间、目录、读写、共享与保护的管理

# 进程管理

## 基本概念

### 结构

* PCB：进程控制块。程序段、相关的数据段、PCB 构成了进程实体

### 基本的 3 种状态

* 就绪：当进程分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。多个就绪的进程被排成一个就绪队列
* 执行：进程已获得 CPU，其程序正在执行
* 阻塞：由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态。多个阻塞的进程被排成一个阻塞队列

### 挂起状态

* 终端用户的请求、父进程请求、负荷调节的需要、操作系统的需要

### 创建状态和终止状态

* 创建状态
  * 创建：为新进程创建 PCB，并填写必要的管理信息。将把其转入就绪状态并放到就绪队列中
  * 创建时主存资源尚未分配，创建工作还未完成，即为创建状态
  * 处于创建状态的进程，获得了必需的资源，以及对其PCB初始化工作完成后，转入就绪状态
* 终止状态
  * 首先等待操作系统进行善后处理，然后将其 PCB 清零，并将 PCB 空间返还系统
  * 到了自然结束点或者出现了无法克服的错误，而被终结
  * 进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。

### PCB 进程控制块

* 作用
  * 是操作系统中进程的记录型数据结构
  * 记录了用于描述进程的当前情况以及控制进程运行的全部信息。
  * 使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。
  * OS 是根据 PCB 来对并发执行的进程进行控制和管理的
* PCB 中的信息
  * 进程标识符：唯一标识一个进程
  * 处理机状态信息：处理机的各种寄存器中的内容
  * 进程调度信息：进程优先级、进程状态、事件（阻塞原因等）、其他（已执行时间、等待CPU时间等）
  * 进程控制信息：程序和数据的地址、进程同步和通信机制（消息队列和信号量）、资源清单、链接指针（该进程在队列中指向下一个进程的PCB的首地址）
  * PCB 的组织方式：一个操作系统中多个 PCB 可以通过链接方式和索引方式

## 进程控制

* 创建进程、终止进程、进程状态转换。由操作系统的内核中的原语实现
* 原语：若干条指令组成，以完成一定功能。常驻内存。实现进程的通信和控制

### 进程创建

> 当操作系统发现出现需要创建进程事件时，会调用进程创建原语创建进程

* 申请空白 PCB。为新进程申请获得一个唯一的标识符，并从 PCB 集合中索取一个空白 PCB
* 为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间
* 初始化进程控制块。
  * 初始化标识信息：将分配的唯一标识符和父进程的标识符填入 PCB 中
  * 初始化处理机状态信息：使程序计数器指向程序的入口地址，使栈指针指向栈顶
  * 初始化处理机控制信息：将进程的状态设置为就绪状态或者静止就绪状态。且一般会将其优先级设置为最低
  * 将新进程插入就绪队列

### 进程的终止

* 正常结束：自然完成自己的使命。在程序的最后安排一条 Holt 指令或者终止系统的调用。当运行到此处时，产生中断，通知 OS 本进程已经完成

* 异常结束：遇到错误或故障而被迫终止

* 外界干预：进程应外界的请求而终止运行

* 终止过程：

  > 若系统发生了终止的事件， OS 便调用进程终止原语，逐步终止进程运行

  * 根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从中读取出该进程的状态
  * 若进程处于运行状态，则立即终止，并设置调度标识为真，以指示该进程被终止之后应重新进行调度
  * 若进程还有子进程，将其所有子进程也都终止
  * 将被终止的进程所拥有的所有资源，归还给父进程或者系统
  * 将被终止的进程 ( PCB ) 从队列中移出，等待其他程序来搜集信息

### 进程的阻塞和唤醒

* 阻塞过程
  * 出现阻塞事件时，进程调用阻塞原语阻塞自己，将进程块中的执行状态改为阻塞状态，并将 PCB 插入到阻塞队列
* 唤醒过程
  * 当被阻塞进程所期待的事件出现时，由其他相关进程调用唤醒原语，将阻塞的进程唤醒
  * 把被阻塞的进程从等待该事件的阻塞队列中移出，将其 PCB 阻塞状态改为就绪，并将 PCB 插入到就绪队列中
  * 就绪队列中的进程等待新的调度
* 当进程执行阻塞原语后，必须通过唤醒原语进行唤醒，才能继续执行，否则永远在阻塞队列中而无法执行

### 进程的挂起与激活

* 挂起：发生挂起进程的事件时，系统使用挂起原语将制定进程挂起
  * 检查进程状态，若处于活动就绪状态，则改为静止就绪；若为活动阻塞状态，则改为静止阻塞
  * 将进程的 PCB 复制到指定的内存区域
  * 若被挂起的进程正在执行，则转向调度程序重新调度
* 激活：发生激活进程的事件时，若进程驻留在外存而内存空降足够，将进程换入内存
  * 激活原语先将进程从外存调入内存，检查进程现行的状态
  * 若为静止就绪，则改为活动就绪
  * 若为静止阻塞，则改为活动阻塞

## 进程同步

> 对多个进程在执行次序上进行协调，使并发的进程能有效的共享资源和相互合作

### 基本概念

* 间接制约（共享资源时）和直接制约（相互合作时）
* 临界资源和临界区：对临界资源必须互斥访问，访问临界资源的那段代码为临界区
* 进入区：访问临界资源前，用于检查欲访问的临界资源是否可以访问
* 退出区：用于将临界区被访问的标志恢复为未被访问
* 实现同步的规则：
  * 空闲让进、忙则等待、有限等待、让权等待

## 进程通信

> 进程间信息交换：状态或者字节数据

### 类型

* 共享存储器系统：相互通信的进程共享某些数据结构或存储区，他们通过这些空间进行通信
  * 基于共享数据结构的通信：相互通信的诸进程公用某些数据结构，实现信息交换
  * 基于共享存储区的通信：对共享存储区中的数据读和写实现通信
* 消息传递系统：最为广泛
  * 进程间数据交换是以格式化的消息（message，或曰：报文）为单位
  * 直接通信
    * OS 提供发送命令，直接把消息发送给目标进程：send 和 receive: message 
  * 间接通信
    * 进程间需要共享数据结构实体（信箱），用于暂存进程消息。发送进程将消息发送至此，接收进程从此取出发给自己的消息
  * 必须先在两者之间建立一条通信链路，在链路使用完以后，显式地拆除链路
  * 消息格式：消息头和消息正文

* 管道通信
  * 用于连接读进程和写进程，是实现进程间通信的一个共享文件：pipe 文件
  * 以字符流的形式将数据送入管道或者从管道接收数据流
  * 源于 UNIX 系统

## 线程

### 基本概念

* 减少程序在并发时付出的开销
* 调度：线程作为调度和分派的基本单位，进程作为资源拥有的基本单位。线程不拥有资源
* 并发：一个进程内多个线程并发
* 系统开销：线程切换仅需要保存和设置少量寄存器内容，不涉及存储器管理方面的内容。进程内的多个线程有相同的地址空间，容易实现同步和通信。线程的切换、同步和通信都不需要系统内核的干预
* 轻型实体：只有一小部分能保证其正常独立运行的资源：线程控制块等

### 线程间同步和通信

* 互斥锁（mutex）：实现线程间对资源互斥访问。操作互斥锁的时间和空间开销比较低。有开锁（unlock）和关锁（lock）两种状态。对共享资源访问时，判断互斥锁的状态，以决定是否执行开锁命令，在访问时，需要执行关锁命令，访问结束需要执行开锁命令，并将阻塞该互斥锁上的其他线程唤醒
* 条件变量：与互斥锁一起使用，随互斥锁的创建而产生。用于线程长时间的等待，直至资源可用

### 线程的实现方式

* 通常进程的创建、撤销、完成IO操作都是利用系统调用而进入内核，再由系统内核中的相应处理程序处理，进程的切换也是在内核的支持下实现的。因此进程和内核紧密相连
* 内核支持线程：线程的创建、撤销、切换也是依靠内核，在内核空间实现。内核空间设置了线程控制块，以使内核感知线程的存在
* 内核可以同时调度和处理同一进程中的多个线程
* 用户级线程：仅存在于用户空间中，与内核无关，节省了内核资源

### 线程的实现

* 内核支持的线程的实现
  * 在创建一个进程时，为其分配一个任务数据区，其中包括若干线程控制块TCB空间
  * 在每一个 TCB 空间中可保存线程标识符、优先级、线程运行的 CPU 状态
  * 线程的撤销过程和进程的相似
* 用户级线程的实现
  * 在用户空间，而非内核。运行在一个中间系统上
  * 运行时系统：用于管理和控制线程的函数集合，包括用于创建和撤销线程的函数、线程同步和通信函数。
  * 内核控制线程：又曰为轻型进程 LWP。每一个进程可以拥有多个 LWP，每个 LWP 都拥有自己的数据结构 TCB。可以通过系统调用以获得内核提供的服务。为控制 LWP 的数量在合理的范围内，又设置了缓冲池，称为线程池

# 处理机调度和死锁

## 处理机调度的层次

### 高级调度

* 把外存上处于后备队列中的作业调入内存，调度对象是作业（每隔几分钟进行一次作业调度）
* 作业和作业步：如，编译 --> 装配 --> 运行
* 作业控制块（JCB）：是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需要的全部信息：标识符等信息和资源
* 作业进入系统时，系统会为其建立JCB，并插入到后备队列中，根据算法进行调度，被调度到的作业会进入内存
* 作业撤销时，回收相关资源、撤销JCB

### 低级调度

* 进程调度、短程调度。调度对象是进程（每个10~100ms进行一次调度）
* 保存处理机的现场信息：程序计数器、多个通用寄存器中的内存
* 根据算法选取进程：优先级、轮转法、从就绪队列中选取进程，并为之分配处理机
* 将处理机分配给进程：由分配程序将处理机分配给进程
* 排队器：将所有的就绪进程按一定方式排成一列或多列
* 分派器：将就绪进程从队列中选出，并进行上下文切换，并分配处理机
* 非抢占式调度：在处理机被分配给线程后，会一直运行直到进程完成，自动释放处理机，不会因为其他原因而被抢占处理机
* 抢占式调度：允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机重新分配给另一个进程。防止处理机被一个进程长期占有，实现进程公平。但是调度开销较大。
  * 时间片原则：各个进程按时间片轮流运行，用完时间片时，停止运行，重新调度
  * 优先权原则：对某些较为重要的、紧急的作业赋予较高的优先级，该类进程可以抢占当前进程的处理机
  * 短作业优先：允许具有明显短时间的进程抢占较长作业的处理机

## 调度队列模型和准则

###调度队列模型 

* 仅有进程调度：分时系统中，在FIFO队列中，按时间片轮转运行和调度
* 有进程调度和作业调度
  * 先按作业调度调入一批作业到内存中，为其建立进程，送入就绪队列中
  * 再按进程调度选取一个进程，为之分配处理机

### 准则

* 面向用户：周转时间短、响应时间快、优先权
* 面向系统：吞吐量高、处理机利用率好、资源得到平衡

## 调度算法

### 先来先服务和短作业优先调度

* 先到先得的进程（利于长时间作业）、运行时间可能比较短的短作业（利于短时间作业）

### 高优先权调度

* 非抢占式和抢占式（比较优先权比重）
* 高响应比
* 等待时间和服务时间之和为响应时间，相当于优先权。越短优先权越高
* 同时照顾了短作业和长作业，较为公平

### 时间片轮转调度

* 基本原理：将就绪进程按FCFS原则排成队列，调度时将CPU分配给队首进程，命令其执行一个时间片(几十毫秒到几百毫秒)，时间片用完时，由计时器发出时钟中断请求，通过该信号停止执行进程，并将该进程送往队尾，再讲=将CPU分配给新的队首进程
* 时间片大小：略大于一次典型的交互所需要的时间，使得大多数的进程都可以在一个时间片内执行完成
* 多级反馈队列调度算法：多个队列，每个队列时间片不同，按队列以此执行。当前一列为空时，进行下一列调度

## 实时调度

### 基本条件

* 必要的信息：就绪时间、开始截止和完成截止时间、处理时间、资源要求、优先级
* 采用抢占调度机制
* 快速切换机制：对外部中断的快速响应、快速的任务分派能力
* 抢占式和非抢占式

## 死锁的原因

* 竞争资源、进程间推进顺序非法
* 预防死锁、避免死锁、检测死锁、解除死锁：剥夺资源撤销进程

# 存储器管理

## 存储器的层次结构

### 多级存储器结构

* CPU 寄存器 --> 主存 --> 辅存
* 对应于：寄存器 --> 高速缓存器、主存储器、磁盘缓存 --> 固定磁盘、可移动存储介质等

### 主存储器和寄存器

* 主存储器：内存、主存。CPU 的控制部件只能从主存储器中取得指令和数据，CPU 与外围设备的信息交换也依托于主存储器的地址空间。其访问速度远低于CPU执行指令的速度，引入了寄存器和高速缓存
* 寄存器：访问速度做最快，用于加速存储器的访问速度

### 高速缓存和磁盘缓存

* 高速缓存：几十KB~几MB。将主存中一些经常访问的信息放到高速缓存中。
  * 进程的程序和数据是放在主存储器中，使用时，被临时复制到一个速度较快的高速缓存中。
  * 一级高速缓存：紧靠内存，速度最高，容量最小。
  * 二级高速缓存：次之，速度稍低，容量稍大
* 磁盘缓存
  * 不是一种实际存在的存储介质，利用内存的存储空间，来暂存从磁盘中读取和写入的数据

## 程序的装入和链接

* 创建进程时，需要首先将长须和数据载入内存
  * 编译：由编译程序将用户源代码编译成若干个目标模块
  * 链接：由链接程序将目标模块及其所需要的库函数链接在一起，形成完整的装入模块
  * 装入：由装入程序将装入模块装入内存

### 装入

* 绝对装入方式：编译时，知道了程序将驻留在内存中的位置，编译程序将产生绝对地址的目标代码。按照装入模块中的地址，将程序和数据装入。之后，由于逻辑地址和实际内存地址相同，无须再修改
* 可重定位装入方式：多道程序环境下，目标模块的起始地址通常从0开始，程序中的其他地址都是相对于该起始地址的
* 动态运行时装入方式：程序装入内存后，并不立即将装入模块中的相对地址转换为绝对地址，当程序真正执行时再进行地址转换

### 链接

* 静态链接：程序运行前，将各个模块及其所需要的库函数链接成一个完整的装配模块，以后不再拆开
* 装入时动态链接：目标模块在装入内存时，边载入边链接
* 运行时动态链接：对特定模块的链接，当程序在执行中需要该模块时，才对其进行链接

## 连续分配方式

* 为一个用户程序分配一个连续的内存空间

### 单一连续分配

* 单用户单任务OS中

### 固定分区分配

* 将内存用户空间划分为几个固定大小的区域，在每个区域中只装入一道作业
* 区域大小相等：当程序太大时，装入不下，程序无法运行。程序太小时，内存空间浪费
* 区域大小不等：多个较小的分区、适量的中分区、少量的大分区
* 内存分配：将区域按大小排列，并为之建立一张分区表。当需要载入程序时，先检索该表以找出满足要求的未被分配的区域，将之分配给该程序。如未找到，则拒绝为其分配内存

### 动态分区分配

* 根据进程的实际需要，动态为之分配内存空间
* 分区分配中的数据结构：用来描述空闲分区和已分配分区的情况。
  * 空闲分区表：其中的每一条记录，记录了分区序号、分区起始地址、分区大小
  * 空闲分区链：分区头设置向前指针，用于链接其他分区，分区尾设置向后指针，链接其他分区
* 分区分配操作
  * 分配内存：若满足条件，将从该分区中划出指定大小的分区，分配给请求者，并将其从分区链中移出
  * 回收内存：待进程释放内存时，系统根据其回收区的首地址，从空闲列表中找到相应的插入点
* 可重定位分区分配
  * 程序容量大于碎片小分区，程序无法装入
  * 需将内存中的所有作业进行移动，使其相互邻接，把原来分散的多个小分区拼接成一个大分区，此时程序可装入

### 对换（swap）

* 把内存中暂时不能运行的进程或者暂时不用的程序和数据调到外存上，腾出空间给具备运行条件的进程
* 外存：文件区（离散分配）+对换区（连续分配）
* 进程的换出：内存空间不够时，选择阻塞状态且优先级低的进程换出，启动磁盘，将程序和数据传送到磁盘的对换区
* 进程的换入：定时查看进程状态，找出就绪且已换出的进程，将其中换出时间最久的进程作为换入进程，换入

## 基本分页存储管理方式

* 离散分配的方式：允许进程直接分散地装入到许多不相邻的分区中基本单位是页或者是段

### 页面与页表

* 分页存储管理是将一个进程的逻辑地址空间分成若干大小相等的片：页面或者页
* 块（页框）：由相等大小的页组成
* 进程分配时，以块为单位，将若干个页分别装入到多个可以不相邻的物理块中。进程最后一页装不满则为页内碎片
* 页面大小需要合适
* 页表：记录相应页在内存中对应的物理块号。

### 地址变换机构

* 将用户地址空间中的逻辑地址转换成内存中的物理地址。页内地址和物理地址是一一对应的，将逻辑地址的页号转换成内存中的物理块号
* 一个页表项用一个寄存器，存储页表在内存中的起始地址和页表长度，大多数的页表驻留在内存中
* CPU 存取数据时，首先访问内存中的页表，从中找到对应页的物理块号，再将块号和页内偏移量拼接形成物理地址。然后再访问内存，从第一次所得的地址中获得数据或写入数据

### 两级和多级页表

* 采用离散分配的方式解决难以找到一块连续的大内存空间问题
* 只将当前需要的页表项调入内存，其余的仍留在磁盘内
* 将页表进行分页，并离散的将各个页面分别存放在不同物理块中。并未离散分配的页表再建立一张页表：外层页表

## 基本分段存储管理方式

### 基本原理

* 分段：作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息
* 段表：为每个段分配一个连续的分区，进程中的各个段可以离散的移入内存中不同的分区中。段表用于记录该段在内存中的起始地址和段的长度

### 段页式存储管理

* 先将用户程序分成若干个段，再把每个段分成若干个页，并未每个段赋予一个段名

## 虚拟存储器

* 是指具有请求调入功能和置换功能，能从逻辑上对内存容量甲乙扩充的一种存储器系统
* 其逻辑容量由内存容量和外存容量之和所决定
* 运行速度接近于内存速度，成本接近于外存

### 实现方式

* 建立在离散分配的存储管理方式上，允许载入少数段或者页的用户程序和数据，即可运行
* 请求分页系统：在分页系统的基础上，增加了请求调页和页面置换功能所形成的页式虚拟存储系统
* 请求分段系统：在分段系统的基础上，增加了请求调段及分段置换功能所形成的段式虚拟存储系统

## 页面调度算法

* 先进先出页面置换算法：总是淘汰（置换）最先进入内存的页面，实际应用极少
* LRU 置换算法：淘汰或者置换最近最久未使用的页面

# 设备管理

## I/O 系统

### I/O 设备

* 实现数据输入输出及数据存储，还需要设备控制总线和高速总线、IO通道、IO 处理机
* 设备不直接与CPU进行通信，而是与设备控制器通信
* IO 设备与设备控制器通信的接口中有3类信号，各对应一条信号线
  * 数据信号线：在设备和设备控制器之间传送数据
  * 控制信号线：作为由设备控制器向IO设备发送控制信号时的通路
  * 状态信号线：传送设备当前状态的信号，正在读、正在写、读完成、写完成

### 设备控制器

* 是计算机的一个实体。用于控制一个或多个IO设备，实现IO设备和计算机的数据交换
* 是CPU和IO设备之间的接口。接收从CPU发送的命令，控制IO设备工作
* 基本功能
  * 接收和识别命令：接收和识别来自于CPU 的不同命令并存储在控制寄存器中，需要控制寄存器
  * 数据交换：作为中介桥梁，实现与CPU和IO设备之间的数据交换，需要数据寄存器
  * 标识和报告设备的状态：以便使CPU确定可以启动控制器并从设备中读取数据，需要状态寄存器
  * 地址识别：能识别设备的地址
  * 数据缓冲：在控制器中设置缓冲器，暂时保存交换而来的数据
  * 差错控制：检测设备传来的数据是否合法，如果有错误，需要向CPU报告
* 组成
  * 与处理机的接口、与设备的接口、IO逻辑

### I/O通道

* 在设备控制器和CPU之间增设通道。建立独立的IO操作，使数据的传送独立于CPU、有关对IO操作的组织管理都独立
* CPU 向通道发送一条IO指令，通道接收后从内存中取出本次要执行的通道程序并执行，完成之后通知CPU
* 指令类型简单，仅限于与IO操作的指令；没有自己的内存，与CPU共享内存

### 总线系统

* 实现CPU、存储器、IO设备之间的联系

## 缓冲管理

* 在数据到达速率和离去速率不同的地方，皆可设置缓冲区
* 在 CPU 和 IO 设备之间建立缓冲区
* 单缓冲和双缓冲：在主存中分配缓冲区
* 循环缓冲：包含多个缓冲区，每个缓冲区大小相同。三种类型（对应三种指针，分别指向这些缓冲区）
  * 用于装输入数据的空缓冲区
  * 已装满数据的缓冲区
  * 计算进程正在使用的现行工作缓冲区
* 循环缓冲区的使用
  * Getbuf 过程：当计算进程要使用缓冲区中的数据时，调用该过程
  * Releasebuf 过程：当计算进程把工作缓冲区数据提取完成时，调用该过程，释放缓存
  * 当进行不同的缓冲过程的时候，需要调整指针指向和缓冲区标记
* 缓冲池：可供若干进程公用的缓冲区
  * 空缓冲区 --> 空缓冲队列
  * 装满输入数据的缓冲区 --> 输入队列
  * 装满输出数据的缓冲区 --> 输出队列

# 文件管理

## 文件和文件系统

* 数据组成：数据项、记录、文件三级

### 文件、记录和数据项

* 数据项是最低级的数据组成形式
  * 基本数据项：用于描述一个对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，又曰字段。学号、姓名、年龄等
  * 组合数据项：由若干基本数据项组成，组项。
  * 数据类型：字符串、整数等
* 记录
  * 一组相关数据项的集合，描述一个对象在某一方面的属性。用一个数据项作为关键字，用来唯一识别记录中的数据项
* 文件
  * 文件类型、文件长度、文件的物理位置、最近一次被修改的时间等

### 文件类型和文件系统模型

* 文件的打开和关闭操作
  * 打开：将指名文件的属性（包括文件在外存上的物理地址）从外存上拷贝到内存打开文件表的一个表目中，并将该表目的编号（或曰索引）返还给用户，当需要对该文件进行操作并向系统发出请求后，系统根据该索引号到打开的文件表中寻找
  * 关闭：从打开的文件表中的表目上删除掉

## 文件的逻辑结构

### 文件的逻辑结构

* 有结构文件：由一个以上的记录构成的文件
  * 定长记录和变长记录
  * 顺序文件、索引文件、索引顺序文件
* 无结构文件：由字符流构成的文件
  * 长度单位是字节。采用读写指针指出下一个将要访问的字符

### 顺序文件

* 两种不同的排列顺序。串结构的顺序与关键字无关，通常由时间来决定。顺序结构的排序按照记录的关键字进行，如英文字母顺序等
* 存取时采用二分法等方法速率可能会比较快
* 增加或者删除记录比较困难

### 索引文件

### 索引顺序文件

## 外存分配方式

* 连续分配、链接分配、索引分配。一个系统采用其中的一种

# UNIX系统内核结构

## 概述

### 内核结构

* 底层的硬件作为整个系统的基础。次级作为核心包括进程管理、存储器管理、设备管理、文件管理。第三层是OS与用户的接口shell以及编译程序等。最后一层次是应用程序。
* OS的核心接口：是核心与硬件的接口，由一组驱动程序和基本的例程组成。另一接口是核心与shell的接口，由两组系统调用及命令解释程序组成
* OS核心又分为：进程控制子系统、文件子系统
* 进程控制子系统：管理处理机和存储器
  * 进程控制：程序可以利用系统调用fork创建一个新进程；exit结束一个进程的执行
  * 进程通信：实现进程间通信的消息机制；用于各进程之间通信的信号工具以及信号量机制
  * 存储器管理：为进程分配物理存储空间；采用段页式存储管理方式；实现了外存与内存间的对换功能
  * 进程调度：采用动态优先数轮转调度算法
* 文件子系统：管理设备和文件
  * 文件管理：为文件分配存储空间、管理空闲盘块、控制对文件的存取、为用户检索数据
  * 高速缓冲机制：设置多个缓冲区，被分别链入各种链表中，如空闲缓冲区链表
  * 设备驱动程序：文件子系统在缓冲机制的支持下，与块设备的驱动程序之间交互作用

## 进程的描述和控制

* Unix 系统采用了段页式存储管理方式。
* 段即为区。进程由若干个段（区）组成。这些区包括：正文程序区、数据区、栈区、共享存储区。
* 每个区分为多个页
* 每个进程还配置一个PCB，装有用于实现对进程管理的和控制的信息

### 进程控制块

* 进程表项：包括常用的核心数据
  * 一些经常被访问的信息，常驻内存
  * 进程标识符：内部标识符，唯一标识一个进程
  * 用户标识符：标识拥有该进程的用户
  * 进程状态：标识该进程的当前状态
  * 事件描述符：记录使进程进入睡眠状态的事件
  * 进程和U区在内存或外存的地址，核心可利用这些信息做上、下文切换。
  * 软中断信息：记录其它进程发来的软中断信号。
  * 计时域：给出进程的执行时间和对资源的利用情况。
  * 进程的大小：是核心在为进程分配存储空间时的依据，包括正文段长度和栈段长
  * 偏置值 nice：供计算该进程的优先数时使用，可由用户设置。
  * P_Link指针：这是指向就绪队列中下一个PCB的指针。
  * 指向 U 区进程正文、数据及栈在内存区域的指针。
* U 区：存放用户进程表项的一些扩充数据。系统为每一个进程设置了一个私用的U区，称之为 user 结构，不常驻内存
  * 进程表项指针：指向当前进程的进程表项
  * 真正用户标识符：由超级用户分配给用户的标识符
  * 有效用户标识符：使用户具有对文件进行操作的权利
  * 用户文件描述符表：记录了该进程已打开的所有文件
  * 当前目录和当前根：用于给出进程的文件系统环境
  * 计时器：记录该进程及其后代在用户态和核心态运行的时间
  * 内部IO参数，给出要传输的数据量、数据的地址、文件的输入输出偏移量
  * 限制字段：对进程大小及其能写的文件大小进行限制
  * 差错字段：记录系统调用执行期间发生的错误
  * 返回值：指出系统调用的执行结果
  * 信号处理数组：用于指示在接收到每一种信号时的处理方式
* 系统区表：存放各个区在物理存储器中的地址信息。进程的虚地址空间分为若干连续的区域，如正文区、数据区和栈区。这些区可以被多个进程共享和保护。为了管理这些区，在核心中设置了一个系统区表，或曰区表
  * 区大小和类型
  * 区的状态：锁住、在请求中、在装入过程、有效（区已装入内存）
  * 区在物理存储器中的位置
  * 引用计数：共享该区的进程数
  * 指向文件索引节点的指针
* 进程区表：存放各区的起始虚地址及指向系统区表中对应区表项的指针
  * 为每个进程配置一张进程区表，表中的每一项，记录一个区的起始虚地址及指向系统区表中对应的区表项的指针

### 进程状态和进程映像

* 进程状态：执行状态、就绪状态、睡眠状态、创建与僵死状态、被强占和被剥夺状态等9种状态
* 进程映像：是正在运行进程的实体，进程是进程映像的执行过程，由三个组成部分
  * 用户级上下文：主要是用户程序，分为正文区和数据区
  * 寄存器上下文：主要由CPU中的一些寄存器的内容组成，
    * 程序寄存器：存放了CPU要执行的下一条指令的虚地址
    * 处理机状态寄存器：存放了运行方式、处理机当前的运行级、记录处理机和该进程有关的硬件状态信息
    * 栈指针：该指针指向栈的下一个自由栈或栈中最后使用的项
    * 通用寄存器：存放进程在运行过程中产生的数据
  * 系统级上下文：包括OS为管理该进程所用的信息
    * 静态部分：进程整个生命期中，静态部分只有一个，大小保持不变，又包括进程表项、U 区及进程表项、系统区表项和页表
    * 动态部分：进程整个生命期中，动态部分的大小可变，包括核心栈和若干层寄存器上下文

### 进程控制

* Unix 系统提供了一组系统调用，用于实现对进程的控制
* fork 系统调用
  * 在 Unix 内核中设置了一个 0 进程，是唯一一个在系统引导时被创建的进程
  * 系统初启时，由0进程再创建1进程，以后0进程变为对换进程，1进程成为系统中的始祖进程
  * fork 为每个终端创建了一个子进程为用户服务。除0进程外的所有进程都由 fork 创建
  * 操作：
    * 为新进程分配一个进程表项和进程标识符。进入 fork 后，核心检查系统是否有足够的资源以创建一个新进程。若资源不足，fork 调用必失败；否则，核心为新进程分配一个进程表项和惟一的进程标识符。
    * 检查同时运行的进程数目。对于普通用户，是否能为之建立进程要受事先设定的、系统允许同时存在的进程数目的限制，超过此限制值时，fork 系统调用失败。
    * 拷贝进程表项中的数据。将父进程表项中的数据拷贝到子进程的进程表项中，并置进程状态为“创建”状态。
    * 子进程继承父进程的所有文件。对父进程的当前目录和所有已打开文件的文件表项中的引用计数 f.count 做加 1 操作，表示这些文件又增加了一个访问者
    * 为子进程创建进程上下文。首先，由核心为子进程创建进程上下文的静态部分，并将其父进程上下文的静态部分拷贝到子进程的上下文中。然后，再为子进程创建进程上下文的动态部分。至此，进程的创建即告结束，再置子进程的状态为“内存中就绪”。最后，返回该子进程的标识符。
    * 子进程执行。当子进程被调度执行时，将 U 区的计时字段初始化后返回 0。
* exec 系统调用
  * fork 调用创建进程时，只是将父进程的用户级上下文拷贝到新建的子进程中。exec 系统调用用于将可执行的二进制文件覆盖在新进程的用户级上下文的存储空间上，以更新新进程的用户级上下文
  * 对可执行文件进行检查：检查文件是否可执行以及是否拥有执行的许可权
  * 回收内存空间：对原来与进程连接的各个区，逐个断开其连接，并收回他们所占用的内存空间
  * 分配存储空间：根据可执行文件的头信息（文件中的正文段和数据段），为每个段分配新区，并连接到进程上，若内存足够则将之装入内存
  * 参数拷贝：将 exec 参数由临时缓冲区拷贝到新的用户栈区，并设置用户态寄存器上下文
* exit 系统调用
  * 撤销进程，及时收回进程占用的资源。父进程在创建子进程时，在子进程尾部安排一条 exit，使其能自我终结
  * 关闭软中断：由于进程即将终止而不再处理任何软中断信号，故应将软中断处理函数关闭
  * 回收资源。关闭所有已打开的文件，释放进程所有的区及相应的内存，释放当前目录及修改根目录的索引结点。
  * 写记账信息。将进程在运行过程中产生的记账数据(含有进程运行时的各种统计数据)记录到一个全局记账文件中。
  * 置进程为“僵死”状态。在做完上述处理后，便可将进程置为“僵死”状态，执行 exit 系统调用的子进程还应向父进程发送“子进程死”的软中断信号，最后由内核进行上下文切换，调度另一进程执行。
* Wait 系统调用
  * 用于将调用进程挂起，直到子进程暂停或终止而发来软中段信号为止
  * 核心查找调用进程是否还有子进程，若无，便返回出错码
  * 如果找到一个处于“僵死”状态的子进程，便将子进程的执行时间加到其父进程的执行时间上，并释放该子进程的进程表项
  * 如果未找到处于“僵死”状态的子进程，则调用进程便在可被中断的优先级上睡眠，等待其子进程发来软中断信号时被唤醒。

### 进程调度和切换

* Unix 是单纯的分时系统，只设置了中级调度（进程对换）和低级调度（进程调度）
* 引起进程调度的原因
  * 时钟中断处理程序须每隔一定时间便对要求进程调度程序进行调度的标志 runrun 予以置位
  * 当进程执行了 wait、exit 及 sleep 等系统调用后要放弃处理机时，也会引起调度程序重新进行调度
  * 当进程执行完系统调用功能而从核心态返回到用户态时，如果系统中又出现了更高优先级的进程在等待处理机时，内核应抢占当前进程的处理机，这也会引起调度
* 调度算法
  * 采用动态优先数轮转调度算法进行进程调度
  * 首先从处于“内存就绪”或“被抢占”状态的进程中选择一个其优先数最小(优先级最高)的进程
  * 将它从其所在队列中移出，并进行进程上下文的切换，恢复其运行
* 进程切换
  * 在 OS 中，凡要进行中断处理和执行系统调用时，都将涉及到进程上下文的保存和恢复，此时系统所保存或恢复的上下文都是属于同一个进程的。而在进程调度之后，内核所应执行的是进程上下文的切换，即内核是把当前进程的上下文保存起来，而所恢复的则是进程调度程序所选中的进程的上下文，以使该进程能恢复执行。

## 进程的同步和通信

* 为进程的同步与进程通信提供了 sleep 和 wakeup 同步机制、管道(pipe)机制和信号(signal)机制、消息机制、共享内存机制、信号量机制

### sleep 与 wakeup 同步机制

* 在执行一般磁盘的读/写操作时，进程要等待磁盘 I/O 完成，此时进程可调用 sleep 使自己进入睡眠状态；当磁盘 I/O 完成时，再由中断处理程序中的 wakeup 将其唤醒。又如，当进程访问一个上了锁的临界资源(如内存索引结点、超级块等)时，进程也将调用 sleep 进入睡眠状态，当其他进程释放该临界资源时，利用 wakeup 将其唤醒。

### 信号机制

* 作为在同一用户的诸进程之间通信的简单工具。信号本身是一个 1~19 中的某个整数，用来代表某一种事先约定好的简单消息。每个进程在执行时，都要通过信号机制来检查是否有信号到达。若有信号到达，表示某进程已发生了某种异常事件，便立即中断正在执行的进程，转向由该信号(某整数)所指示的处理程序，去完成对所发生的事件(事先约定)的处理。处理完毕，再返回到此前的断点处继续执行
* 功能
  * 发送信号：由发送进程间信号发送到指定目标进程信号域
  * 设置对信号的处理方式：利用系统调用 signal 来预置对信号的处理方式
  * 处理信号：当一个进程要进入或退出一个低优先级睡眠状态时，或一个进程即将从核心态返回到用户态时，核心都要检查该进程是否已收到信号；仅当进程返回到用户态时，才处理信号，转向相应信号的处理程序，处理完后，再返回到用户程序的断点

### 管道机制

* 所谓管道，是指能够连接一个写进程和一个读进程、并允许它们以生产者—消费者方式进行通信的一个共享文件，又称为 pipe 文件。由写进程从管道的入端将数据写入管道，而读进程则从管道的出端读出数据

### 消息机制

* 消息和消息队列
* 消息队列的建立
  * 调用 msgget 建立一个指名的消息队列。该系统调用将搜索消息队列头标表，以确定是否有指定名字的消息队列，无则分配一个新的消息队列头标并初始化并返回，有则直接返回
* 消息队列的操作
  * 调用 msgctl 对指定的消息队列进行操纵
  * msgid 为消息队列描述符；cmd 是规定的命令；buf 是用户缓冲区地址
  * 命令
    * 用于查询有关消息队列的情况的命令
    * 用于设置和改变有关消息队列的属性的命令
    * 用于消除消息队列的标识符的命令
* 消息的发送
  * 调用 msgsend 发送消息。检查消息合法后，为消息分配消息数据区，并将消息从用户消息缓冲区拷贝到信息数据区。分配消息首部，将其加入消息队列的尾部；在首部中填写消息的类型、大小、及指向消息数据区的指针；修改消息队列头标中的数据；唤醒睡眠的进程
* 消息的接收
  * 调用 msgrcv 从消息队列读取一个消息。先检查消息队列标识符和许可权
  * 核心将消息正文拷贝到用户区，再从队列中删除该消息，并唤醒睡眠的发送进程

### 共享存储区机制

* 共享存储区机制是Unix系统中通信速度最高的一种通信机制
* 使若干进程共享主存中的某个区域，且使该区域出现在多个进程的虚地址空间中
* 共享存储区的建立
  * 调用 shmget 建立共享存储区。若已建立则返回该区的描述符，否则建立指定大小的共享存储区
* 共享存储区的操纵
  * 调用 shmctl 查询共享存储的状态信息、修改或者设置属性以及共享区的标识符等
* 共享存储区的附接与断开
  * 在进程已经建立了共享存储区或者已经获得了描述符后，还需调用 shmat 将该区附接到用户指定的某个进程的虚地址上，并指定访问属性。当进程不再需要该共享存储区时，调用 shmdt 将该区与进程断开

### 信号量机制

* 信号量：信号量有一个可用来表示某类资源数目的信号量值和一个操作值，为一个整数
* Unix 中采用 semop 调用对指定的信号量施加操作、semget 建立信号量、semctl 调用对信号量的操作
* 信号量集：包含多个信号量，一个信号量集是一个整体。按照原子方式操作
* 信号量表：是信号量的结构数组：包括信号量值、进程标识符等
* 信号量集表：是信号量集的索引结构数组，其中的每一个元素都对应于一个信号量集。包括访问权限、指向信号量集中第一个信号量的指针、信号量集中信号量的数目、最近对信号量执行操作的时间
* semget 调用：建立信号量集。建立成功则返回信号量集中的描述符
* semop 调用：对信号量集进行操作

## 存储器管理

### 请求调页管理的数据结构

* 页表：为了实现请求调页策略，UNIX 系统V将进程的每个区分为若干个虚页，可把这些虚页分配到不相邻接的页框中，为此而设置了一张页表。在其每个表项中，记录了每个虚页和页框间的对照关系
* 磁盘块描述块：记录进程在不同时候的每个虚页在硬盘中的盘块号。在请求调页机制中，若发现缺页，系统应将所缺页调入内存。但应从何处将其调入内存呢? 对于同一个虚页，在不同情况下应从不同的地方调入内存。当进程在运行中发现缺页时，可通过查找该页表的方法来找到所需调入页面的位置。
  * 一个进程的每一页对应一个磁盘描述表项：它描述了每一个虚页的磁盘拷贝
  * 包括对换设备号、设备块号和存储器类型
* 页框数据表：每个页框数据表项描述了内存的一个物理页
  * 页状态：指示该页的拷贝是在对换设备上，还是在可执行文件中
  * 内存引用计数：指出引用该页面的进程数目
  * 逻辑设备：指含有此拷贝的逻辑设备，它可以是对换设备，也可以是文件系统
  * 块号：当逻辑设备为对换设备时，这是盘块号；而当逻辑设备为文件系统时，这是指文件的逻辑块号
  * 指针 1：指向空闲页链表中的下一个页框数据表的指针
  * 指针 2：指向散列队列中下一个页框数据表的指针
* 对换使用表：对换设备上的每一页都占有对换使用表的一个表项，表项中含有一个引用计数，其数值表示有多少页表项指向该页

### 换页进程

* 即 0 进程。每隔一定时间，对内存中的所有有效页的年龄加 1，以及当有效页的年龄达到规定值后，便将它换出