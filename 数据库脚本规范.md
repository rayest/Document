# Mysql 脚本规范

> 严格遵守 UTF-8 无 BOM 编码格式

## Mysql 规范

* 添加`created_at`和`updated_at`字段。针对业务和日志表，需要添加该两个字段，且当数据变更时需要更新 		`updated_at`字段

* 每张表和字段需要添加中文备注，以说明其意义和用途

* `DML(数据库操作语言)`和`DDL(数据库定义语言)`语句需要分开执行

* 建表时，设置自增列的名字都为`id`，除非特殊原因

* 自增列`id` 的类型需要设置成`int unsigned`或者`bigint unsigned`，默认主键都采用非负的整数并添加自增属性 `AUTO_INCREMENT`，注意自增主键不要再设置`default`属性

* 建表时，自增主键列的起始自增值需要设置为1（`AUTO_INCREMENT`=1）

* 索引名字统一前缀为`idx_`，表示 `index`；唯一索引统一前缀为 `uniq _`

* 默认值

  * 可添加默认值的字段，都添加默认值，默认值尽量都不使用`null`，其原因是：
  * `null`是非确定性的类型。值为`null`所在的列会使索引、索引统计、值比较都更加复杂
  * 使得`mysql`更难优化，不利于索引查询效率
  * `null`值使得`mysql`内部需要进行特殊处理，增加数据库处理记录的复杂性
  * 同等条件下，表中太多`null`值会降低数据库处理性能
  * `null`的存储需要特殊的字节标注，表和索引中每行为`null`的列需要额外的一个字节进行标识
  * 对`null`的处理，只能使用`is null`或者`is not null`
  * 如果要设置默认值，字符串类型可以设置空字符串`""`表示；整型可以选择一个无业务意义的默认数字；日期类型选择系统当前的日期和时间填充
  * 查询数据，尽可能避免使用`SELECT *`，需要什么查询什么。以减少带宽和数据库实例资源消耗
  * `DML`语句中不要忘记使用`where`条件过滤，过滤条件需要有索引并预计影响行数
  * 建表时，如果时间类型的字段设置了默认值，需要确认字段是否在取值范围内

  ```bash
  DATE('1000-01-01' to '9999-12-31')
  DATETIME('1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999')
  - CST China Standard Time UTC+8:00 中国沿海时间(北京时间)
  TIMESTAMP('1970-01-01 00:00:01.000000' UTC to '2038-01-19 03:14:07.999999' UTC)
  - CST China Standard Time UTC+8:00 中国沿海时间(北京时间)
  ```

  * 线上创建新表时，不要添加`(DROP TABLE IF EXISTS 表名)`以防误`drop`表，特殊需要可以单独处理

## Mysql 优化

* 每张表必须要创建一个主键，尽量设置一个自增的主键列，主键值尽量短小，因为其他非主键索引都要引用主键值作为自身索引结构的叶子节点

* 如果自增主键值过大，会导致非主键索引变得非常大，即过长的主键索引使得辅助索引过大

* 对于修改频繁的列不创建索引

* 建议`InnoDB`存储引擎的表主键设置为单调递增。可以使用改进后的`B+`树分裂策略，显著减少其分裂次数和数据迁移，提高插入效率和索引页空间利用率

* 聚簇索引

  * 是`InnoDB`引擎的特性，如果需要该索引，只要将索引指定为主键`(primary key)`就可以了
  * 在`InnoDB`中，索引对应的叶子上存储对应的行数据，主索引文件上即主键直接存储改行的数据，辅助索引指向对主键的引用
  * 主键索引既存储索引值，又在叶子中存储行数据
  * 若没有显示指定主键，则选择`unique key`作为主键
  * 若没有指定`unique`，则系统生成一个内部的`rowid`作为主键
  * 若遇到`InnoDB`的主键以不规则的方式插入时，会造成频繁的页分裂
  * 聚簇索引的分裂过程
    * 数据无论有序或者无序的方式进行插入时，都会保持以`btree`形式有序存储
    * 当插入无序的数据时，需要对已经存在的页进行分裂插入
    * 而主键采取自增的有序方式时，插入时不会造成大量的页分裂和页移动

* 索引

  * `show index from table_name` 查看表索引
  * 对`where`后面的过滤列，使用`频率高`和`选择性高`的列可以创建联合索引；将唯一性和过滤高的列放在联合索引的最前面
  * 对列值范围较窄，且每个值重复率分布比较均匀，如性别等无需创建索引
  * 避免冗余和重复索引。如联合索引`idx_a_b_c(a,b,c)`相当于`(a)、(a,b)、(a,b,c)`，则索引` (a)、(a,b)`多余
  *  尽量避免对`update/delete`频繁的字段创建索引，要保证`update/delete`的字段是通过其它唯一性高的索引列所过滤定位的（目标是，创建索引的字段，尽量不要经常做修改，数据修改后，索引结构也要重新调整和平衡，要尽量减少索引自身结构的修改）

  *  ```bash
    比如： `update_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',（这个记录数据变更时间的字段，一般不适合创建索引）
     ```

  * 最左前缀匹配原则。`MySQL`会一直向右匹配直到遇到范围查询`(>、<、between、like 或者有时候 !=/<>)`就停止索引的匹配，比如`a = 1 and b = 2 and c > 3 and d = 4` 如果建立`(a,b,c,d)`顺序的索引，`d`是用不到索引的，如果建立`(a,b,d,c)`的索引则都可以用到，`a,b,d`的顺序可以任意调整

  * `MySQL B+`树 `index`的一般使用

    * 索引尽量创建在重复率低，选择性较高的列上，最好列值是唯一的
    * 尽量在`where`搜索的上列创建索引或者连接子句的列上
    * `where`列在使用通配符时，注意避免开头使用通配符%

       ```bash
    如下2条语句将使用索引:
    SELECT * FROM tbl_name WHERE key_col LIKE 'Patrick%';
    SELECT * FROM tbl_name WHERE key_col LIKE 'Pat%_ck%';
    而下面2条语句则不使用索引：
    SELECT * FROM tbl_name WHERE key_col LIKE '%Patrick%';
    SELECT * FROM tbl_name WHERE key_col LIKE other_col;
      
 ```

* hhhh
